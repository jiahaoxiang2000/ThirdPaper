FIPS  205

Federal  Information  Processing  Standards  Publication

Stateless  Hash-Based  Digital  Signature
Standard

Category:  Computer  Security

Subcategory:  Cryptography

Information Technology Laboratory
National Institute of Standards and Technology
Gaithersburg, MD 20899-8900

This publication is available free of charge from:
https://doi.org/10.6028/NIST.FIPS.205

Published:  August 13, 2024

U.S.  Department  of  Commerce
Gina M. Raimondo, Secretary

National  Institute  of  Standards  and  Technology
Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology

Foreword

The Federal Information Processing Standards Publication (FIPS) series of the National Institute of Standards
and Technology (NIST) is the official series of publications relating to standards and guidelines developed
under 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.

Comments concerning this Federal Information Processing Standard publication are welcomed and should
be submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement
section.

Kevin M. Stine, Director
Information Technology Laboratory

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Abstract
This standard specifies the stateless hash-based digital signature algorithm (SLH-DSA). Digital
signatures are used to detect unauthorized modifications to data and to authenticate the identity
of the signatory. In addition, the recipient of signed data can use a digital signature as evidence in
demonstrating to a third party that the signature was, in fact, generated by the claimed signatory.
This is known as non-repudiation since the signatory cannot easily repudiate the signature at a
later time. SLH-DSA is based on SPHINCS+ , which was selected for standardization as part of the
NIST Post-Quantum Cryptography Standardization process.

Keywords: computer security; cryptography; digital signatures; Federal Information Processing
Standards; hash-based signatures; post-quantum; public-key cryptography.

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Federal  Information  Processing  Standards  Publication  205

Published:  August  13,  2024
Effective:  August  13,  2024

Announcing  the
Stateless  Hash-Based  Digital  Signature  Standard

Federal Information Processing Standards (FIPS) publications are developed by the National
Institute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary
of Commerce under 40 U.S.C. 11331.

1.  Name of Standard. Stateless Hash-Based Digital Signature Standard (FIPS 205).

2.  Category of Standard. Computer Security. Subcategory. Cryptography.

3.  Explanation. This standard specifies a stateless hash-based digital signature scheme (SLH-
DSA) for applications that require a digital signature rather than a written signature. Additional
digital signature schemes are specified and approved in other NIST Special Publications and
FIPS publications (e.g., FIPS 186-5 [1]). A digital signature is represented in a computer as a
string of bits and computed using a set of rules and parameters that allow the identity of the
signatory and the integrity of the data to be verified. Digital signatures may be generated on
both stored and transmitted data.

Signature generation uses a private key to generate a digital signature. Signature verification
uses a public key that corresponds to but is not the same as the private key. Each signatory
possesses a private and public key pair. Public keys may be known by the public, but private
keys must be kept secret. Anyone can verify the signature by employing the signatoryâ€™s public
key. Only the user who possesses the private key can perform signature generation.

The digital signature is provided to the intended verifier along with the signed data.  The
verifying entity verifies the signature by using the claimed signatoryâ€™s public key.  Similar
procedures may be used to generate and verify signatures for both stored and transmitted
data.

This standard specifies several parameter sets for SLH-DSA that are approved for use. Addi-
tional parameter sets may be specified and approved in future NIST Special Publications.

4.  Approving Authority. Secretary of Commerce.

5.  Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-

nology, Information Technology Laboratory (ITL).

6.  Applicability.  This standard is applicable to all federal departments and agencies for the
protection of sensitive unclassified information that is not subject to section 2315 of Title 10,
United States Code, or section 3502 (2) of Title 44, United States Code. Either this standard,
FIPS 204, FIPS 186-5, or NIST Special Publication 800-208 shall be used in designing and
implementing public-key-based signature systems that federal departments and agencies op-
erate or that are operated for them under contract. In the future, additional digital signature

i

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

schemes may be specified and approved in FIPS publications or NIST Special Publications.

The adoption and use of this standard are available to private and commercial organizations.

7.  Applications. A digital signature algorithm allows an entity to authenticate the integrity of
signed data and the identity of the signatory. The recipient of a signed message can use a
digital signature as evidence in demonstrating to a third party that the signature was, in fact,
generated by the claimed signatory. This is known as non-repudiation since the signatory
cannot easily repudiate the signature at a later time. A digital signature algorithm is intended
for use in electronic mail, electronic funds transfer, electronic data interchange, software
distribution, data storage, and other applications that require data integrity assurance and
data origin authentication.

8.  Implementations. A digital signature algorithm may be implemented in software, firmware,
hardware, or any combination thereof. NIST will develop a validation program to test imple-
mentations for conformance to the algorithms in this standard.  For every computational
procedure that is specified in this standard, a conforming implementation may replace the
given set of steps with any mathematically equivalent process.  In other words, different
procedures that produce the correct output for every input are permitted. Information about
validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples for digital
signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards-
and-guidelines/example-values.

Agencies are advised that digital signature key pairs shall not be used for other purposes.

9.  Other Approved Security Functions. Digital signature implementations that comply with this
standard shall employ cryptographic algorithms that have been approved for protecting Fed-
eral Government-sensitive information. Approved cryptographic algorithms and techniques
include those that are either:

a.  Specified in a Federal Information Processing Standard (FIPS) publication,

b.  Adopted in a FIPS or NIST recommendation, or

c.  Specified in the list of approved security functions in SP 800-140C.

10. Export Control. Certain cryptographic devices and technical data regarding them are subject
to federal export controls. Exports of cryptographic modules that implement this standard
and technical data regarding them must comply with these federal regulations and be licensed
by the Bureau of Industry and Security of the U.S. Department of Commerce. Information
about export regulations is available at https://www.bis.doc.gov.

11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.

12. Implementation Schedule. This standard becomes effective immediately upon final publica-

tion.

13. Specifications. Federal Information Processing Standard (FIPS) 205, Stateless Hash-Based

Digital Signature Standard (affixed).

ii

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

14. Qualifications.  The security of a digital signature system depends on the secrecy of the
signatoryâ€™s private keys. Signatories shall, therefore, guard against the disclosure of their
private keys. While it is the intent of this standard to specify general security requirements for
generating digital signatures, conformance to this standard does not ensure that a particular
implementation is secure. It is the responsibility of an implementer to ensure that any module
that implements a digital signature capability is designed and built in a secure manner.

Similarly, the use of a product containing an implementation that conforms to this standard
does not guarantee the security of the overall system in which the product is used. The re-
sponsible authority in each agency or department shall ensure that an overall implementation
provides an acceptable level of security.

Since a standard of this nature must be flexible enough to adapt to advancements and
innovations in science and technology, this standard will be reviewed every five years in order
to assess its adequacy.

15. Waiver Procedure.  The Federal Information Security Management Act (FISMA) does not
allow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory
by the Secretary of Commerce.

16. Where to Obtain Copies of the Standard. This publication is available by accessing https:
//csrc.nist.gov/publications. Other computer security publications are available at the same
website.

17. How to Cite This Publication. NIST has assigned NIST FIPS 205 as the publication identifier
for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends
that it be cited as follows:

National Institute of Standards and Technology (2024) Stateless Hash-Based Dig-
ital Signature Standard.  (Department of Commerce,  Washington,  D.C.),  Fed-
eral Information Processing Standards Publication (FIPS) NIST FIPS 205.  https:
//doi.org/10.6028/NIST.FIPS.205

18. Inquiries and Comments.  Inquiries and comments about this FIPS may be submitted to

fips-205-comments@nist.gov.

iii

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Federal  Information  Processing  Standards  Publication  205

Specification  for  the
Stateless  Hash-Based  Digital  Signature  Standard

Table of Contents

1  Introduction

1.1  Purpose and Scope  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2  Context  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2  Glossary of Terms, Acronyms, and Symbols

2.1  Terms and Definitions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2  Acronyms  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3  Mathematical Symbols  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3  Overview of the SLH-DSA Signature Scheme

3.1  Additional Requirements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

1

1

2

2

4

5

7

9

3.2

Implementation Considerations  . . . . . . . . . . . . . . . . . . . . . . . . .

10

4  Functions and Addressing

4.1  Hash Functions and Pseudorandom Functions

. . . . . . . . . . . . . . . . .

4.2  Addresses  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.3  Member Functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.4  Arrays, Byte Strings, and Integers

. . . . . . . . . . . . . . . . . . . . . . . .

5  Winternitz One-Time Signature Plus Scheme

5.1  WOTS+  Public-Key Generation  . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2  WOTS+  Signature Generation
5.3  Computing a WOTS+  Public Key From a Signature

. . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . .

6  eXtended Merkle Signature Scheme (XMSS)

6.1  Generating a Merkle Hash Tree

. . . . . . . . . . . . . . . . . . . . . . . . .

6.2  Generating an XMSS Signature  . . . . . . . . . . . . . . . . . . . . . . . . . .

6.3  Computing an XMSS Public Key From a Signature  . . . . . . . . . . . . . . . .

7  The SLH-DSA Hypertree

iv

11

11

11

14

15

17

18

19

21

22

22

23

25

26

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

7.1  Hypertree Signature Generation  . . . . . . . . . . . . . . . . . . . . . . . . .

7.2  Hypertree Signature Verification  . . . . . . . . . . . . . . . . . . . . . . . . .

8  Forest of Random Subsets (FORS)

8.1  Generating FORS Secret Values . . . . . . . . . . . . . . . . . . . . . . . . . .

8.2  Generating a Merkle Hash Tree

. . . . . . . . . . . . . . . . . . . . . . . . .

8.3  Generating a FORS Signature  . . . . . . . . . . . . . . . . . . . . . . . . . . .

8.4  Computing a FORS Public Key From a Signature  . . . . . . . . . . . . . . . . .

9  SLH-DSA Internal Functions

9.1  SLH-DSA Key Generation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

9.2  SLH-DSA Signature Generation  . . . . . . . . . . . . . . . . . . . . . . . . . .

9.3  SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .

10 SLH-DSA External Functions

10.1  SLH-DSA Key Generation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10.2  SLH-DSA Signature Generation  . . . . . . . . . . . . . . . . . . . . . . . . . .
10.2.1  Pure SLH-DSA Signature Generation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
10.2.2  HashSLH-DSA Signature Generation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
10.3  SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .

11 Parameter Sets

11.1  SLH-DSA Using SHAKE

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11.2  SLH-DSA Using SHA2  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.2.1  SLH-DSA Using SHA2 for Security Category 1 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .
11.2.2  SLH-DSA Using SHA2 for Security Categories 3 and 5

References

Appendix A â€” Differences From the SPHINCS+  Submission

A.1  Changes From FIPS 205 Initial Public Draft . . . . . . . . . . . . . . . . . . . .

26

28

29

29

30

30

31

33

33

34

36

37

37

37
38
39
41

43

44

44
45
46

47

51

51

v

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

List of Tables

Table 1  Member functions for addresses  . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
Table 2
Table 3  Member functions for compressed addresses  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .

SLH-DSA parameter sets

14
43
45

List of Figures

An SLH-DSA signature  . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Address (ADRS)
Figure 2
Figure 3  WOTS+  hash address
. . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 4  WOTS+  public-key compression address
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
Hash tree address  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 5
FORS tree address  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 6
Figure 7
FORS tree roots compression address  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
Figure 8  WOTS+  key generation address  . . . . . . . . . . . . . . . . . . . . . .
Figure 9
. . . . . . . . . . . . . . . . . . . . . . .
Figure 10  WOTS+  signature data format  . . . . . . . . . . . . . . . . . . . . . . .
Figure 11  XMSS signature data format  . . . . . . . . . . . . . . . . . . . . . . . .
Figure 12  Merkle hash tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
Figure 13  HT signature data format
FORS signature data format  . . . . . . . . . . . . . . . . . . . . . . . .
Figure 14
SLH-DSA private key  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 15
SLH-DSA public key . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figure 16
Figure 17
SLH-DSA signature data format
. . . . . . . . . . . . . . . . . . . . . .
ğ‘
Figure 18  Compressed address (ADRS  ) . . . . . . . . . . . . . . . . . . . . . .

FORS key generation address

List of Algorithms

Algorithm 1
Algorithm 2
Algorithm 3
Algorithm 4
Algorithm 5
Algorithm 6
Algorithm 7
Algorithm 8
Algorithm 9
Algorithm 10
Algorithm 11
Algorithm 12
Algorithm 13
Algorithm 14

gen_len2(ğ‘›, ğ‘™ğ‘”ğ‘¤)
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
toInt(ğ‘‹, ğ‘›) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
toByte(ğ‘¥, ğ‘›)
base_2b(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)
. . . . . . . . . . . . . . . . . . . . . . . .
chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)  . . . . . . . . . . . . . . . . . . .
wots_pkGen(SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . .
wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)
. . . . . . . . . . . . .
wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS) . . . . . . . . . . . . .
. . . . . . . . . . . .
xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)
xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS) . . . . . . . . . . .
xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS) . . . . . . .
. . . . . . . . . .
ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“)
ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, PK.root)  . . . . . .
fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)  . . . . . . . . . . . .

8
12
12
12
13
13
13
14
14
19
22
24
26
29
33
33
34
45

10
15
15
16
18
18
20
21
23
24
25
27
28
29

vi

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm
Algorithm

15
16
17
18
19
20
21
22
23
24
25

. . . . . . . . . . . . .
fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)
fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)
. . . . . . . . . . . . .
fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘†, ğ‘šğ‘‘, PK.seed, ADRS) . . . . . . . . . .
. . . . . . . . . .
slh_keygen_internal(SK.seed, SK.prf, PK.seed)
slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . .
slh_verify_internal(ğ‘€, SIG, PK)
. . . . . . . . . . . . . . . . . . . .
slh_keygen()  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)  . . . . . . . . . . . . . . . . . . . . . . . . . .
hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)  . . . . . . . . . . . . . . . . . . . . .
slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK) . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)

30
31
32
34
35
36
37
39
40
41
42

vii

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

1.

Introduction

1.1  Purpose  and  Scope

This standard defines a method for digital signature generation that can be used for the protection
of binary data (commonly called a message) and for the verification and validation of those digital
signatures.1
The security of the stateless hash-based digital signature algorithm (SLH-DSA) relies
on the presumed difficulty of finding preimages for hash functions as well as several related
properties of the same hash functions. Unlike the algorithms specified in FIPS 186-5 [1], SLH-DSA
is designed to provide resistance against attacks from a large-scale quantum computer.

This standard specifies the mathematical steps that need to be performed for key generation,
signature generation, and signature verification. Additional assurances are required for digital
signatures to be valid (e.g., the assurance of identity and private key possession).  SP 800-89,
Recommendation for Obtaining Assurances for Digital Signature Applications [3], specifies the
required assurances and the methods for obtaining these assurances.

1.2  Context

Over the past several years, there has been steady progress toward building quantum computers.
The security of many commonly used public-key cryptosystems will be at risk if large-scale
quantum computers are ever realized. This would include key-establishment schemes and digital
signatures that are based on integer factorization and discrete logarithms (both over finite fields
and elliptic curves).  As a result, in 2016, NIST initiated a public Post-Quantum Cryptography
(PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms
for standardization. A total of 82 candidate algorithms were submitted to NIST for consideration.

After three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-
dardization. These algorithms are intended to protect sensitive U.S. Government information
well into the foreseeable future, including after the advent of cryptographically relevant quan-
tum computers.  This standard includes the specification for one of the algorithms selected:
SPHINCS+ , a stateless hash-based digital signature scheme. This standard contains several minor
modifications compared to Version 3 [4], which was submitted at the beginning of round three
of the NIST PQC Standardization process. The changes are described in Appendix A. Throughout
this standard, SPHINCS+  will be referred to as SLH-DSA for stateless hash-based digital signature
algorithm.

1NIST Special Publication (SP) 800-175B [2], Guideline for Using Cryptographic Standards in the Federal Government:
Cryptographic Mechanisms, includes a general discussion of digital signatures.

1

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

2.  Glossary  of  Terms,  Acronyms,  and  Symbols

2.1  Terms  and  Definitions

approved

big-endian

FIPS-approved  and/or  NIST-recommended.  An  algorithm  or  tech-
nique that is either 1) specified in a FIPS or NIST recommendation, 2)
adopted in a FIPS or NIST recommendation, or 3) specified in a list of
NIST-approved security functions. [1]

The property of a byte string having its bytes positioned in order of
decreasing significance.  In particular, the leftmost (first) byte is the
most significant, and the rightmost (last) byte is the least significant.
The term â€œbig-endianâ€ may also be applied in the same manner to bit
strings. [5, adapted]

byte string

An array of integers in which each integer is in the set {0, â€¦ , 255}.

claimed signatory

From the verifierâ€™s perspective, the claimed signatory is the entity that
purportedly generated a digital signature. [1]

destroy

digital signature

An action applied to a key or a piece of secret data. After a key or a
piece of secret data is destroyed, no information about its value can
be recovered. [1]

The result of a cryptographic transformation of data that, when prop-
erly implemented, provides a mechanism for verifying origin authenti-
cation, data integrity, and signatory non-repudiation. [1]

entity

An individual (person), organization, device, or process.  Used inter-
changeably with party. [1]

equivalent process

extendable-output
function

Two processes are equivalent if the same output is produced when
the same values are input to each process (either as input parameters,
as values made available during the process, or both). [1]

A function on bit strings in which the output can be extended to any
desired length. Approved XOFs (such as those specified in FIPS 202 [6])
are designed to satisfy the following properties as long as the specified
output length is sufficiently long to prevent trivial attacks:

1.  (One-way) It is computationally infeasible to find any input that

maps to any new pre-specified output.

2.  (Collision-resistant) It is computationally infeasible to find any
two distinct inputs that map to the same output. [7, adapted]

fresh random value  A previously unused output of a random bit generator.

hash function

A function on bit strings in which the length of the output is fixed.
Approved hash functions (such as those specified in FIPS 180 [8] and
FIPS 202 [6]) are designed to satisfy the following properties:

2

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

1.  (One-way) It is computationally infeasible to find any input that

maps to any new pre-specified output

2.  (Collision-resistant) It is computationally infeasible to find any

two distinct inputs that map to the same output. [1]

hash value

See message digest.

key

A parameter used in conjunction with a cryptographic algorithm that
determines its operation. Examples applicable to this standard include:

key pair

message

message digest

non-repudiation

owner

party

private key

pseudorandom

public key

1.  The computation of a digital signature from data, and

2.  The verification of a digital signature. [1]

A public key and its corresponding private key. [1]

The data that is signed. Also known as signed data during the signature
verification and validation process. [1]

The result of applying a hash function to a message. Also known as a
hash value. [1]

A service that is used to provide assurance of the integrity and origin
of data in such a way that the integrity and origin can be verified and
validated by a third party as having originated from a specific entity in
possession of the private key (i.e., the signatory). [1]

A key pair owner is the entity authorized to use the private key of a
key pair. [1]

An individual (person), organization, device, or process.  Used inter-
changeably with entity. [1]

A cryptographic key that is used with an asymmetric (public-key) cryp-
tographic algorithm. The private key is uniquely associated with the
owner and is not made public. The private key is used to compute a
digital signature that may be verified using the corresponding public
key. [1]

A process or data produced by a process is said to be pseudorandom
when the outcome is deterministic yet also effectively random as long
as the internal action of the process is hidden from observation. For
cryptographic purposes, â€œeffectively randomâ€ means â€œcomputation-
ally indistinguishable from random within the limits of the intended
security strength.â€ [1]

A cryptographic key that is used with an asymmetric (public-key) cryp-
tographic algorithm and is associated with a private key. The public
key is associated with an owner and may be made public. In the case
of digital signatures, the public key is used to verify a digital signature
that was generated using the corresponding private key. [1]

3

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

security category

A number associated with the security strength of a post-quantum
cryptographic algorithm, as specified by NIST (see [9, Sect. 5.6]).

security strength

A number associated with the amount of work (i.e., the number of
operations) that is required to break a cryptographic algorithm or
system. [1]

shall

should

signatory

Used to indicate a requirement of this standard. [1]

Used to indicate a strong recommendation but not a requirement of
this standard. Ignoring the recommendation could result in undesir-
able results. [1]

The entity that generates a digital signature on data using a private
key. [1]

signature generation  The process of using a digital signature algorithm and a private key to

generate a digital signature on data. [1]

signature validation  The (mathematical) verification of the digital signature and obtain-
ing the appropriate assurances (e.g., public-key validity, private-key
possession, etc.). [1]

signature verification  The process of using a digital signature algorithm and a public key to

verify a digital signature on data. [1]

signed data

verifier

The data or message upon which a digital signature has been computed.
Also see message. [1]

The entity that verifies the authenticity of a digital signature using the
public key. [1]

2.2  Acronyms

ADRS
ADRSc

AES

DER

FIPS

FORS

ITL

MGF

NIST

OID

PQC

PRF

Address

Compressed Address

Advanced Encryption Standard

Distinguished Encoding Rules

Federal Information Processing Standard

Forest of Random Subsets

Information Technology Laboratory

Mask Generation Function

National Institute of Standards and Technology

Object Identifier

Post-Quantum Cryptography

Pseudorandom Function

4

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

SHA

SHAKE

SP

RFC
WOTS+

XMSS

XOF

Secure Hash Algorithm

Secure Hash Algorithm KECCAK

Special Publication

Request for Comments

Winternitz One-Time Signature Plus

eXtended Merkle Signature Scheme

eXtendable-Output Function

2.3  Mathematical  Symbols

ğ‘‹ âˆ¥ ğ‘Œ

ğ‘‹[ğ‘– âˆ¶ ğ‘—]

Truncâ„“(ğ‘‹)

|ğ‘‹|

âŒˆğ‘âŒ‰

âŒŠğ‘âŒ‹

The concatenation of two arrays ğ‘‹ and ğ‘Œ. If ğ‘‹ is an array of length â„“ ,ğ‘¥
 array of length
and ğ‘Œ is an array of length â„“ , then ğ‘  = ğ‘‹ âˆ¥ ğ‘Œ is an
â„“ğ‘¥  + â„“ such
ğ‘¦

 that

ğ‘¦

ğ‘[ğ‘–] = {

ğ‘‹[ğ‘–]
ğ‘Œ [ğ‘– âˆ’ â„“ğ‘¥]

if 0 â‰¤ ğ‘– < â„“ğ‘¥
if â„“ğ‘¥  â‰¤ ğ‘– < â„“ğ‘¥ + â„“ğ‘¦.

A subarray of ğ‘‹.  If ğ‘‹ is an array of length â„“ ,
ğ‘¥  0 â‰¤ ğ‘– < ğ‘—  â‰¤ â„“ğ‘¥  and
ğ‘Œ  =  ğ‘‹[ğ‘–  âˆ¶  ğ‘—], then ğ‘Œ is an array of length ğ‘— âˆ’ ğ‘– such that ğ‘Œ [ğ‘˜]  =
ğ‘‹[ğ‘– + ğ‘˜] for 0 â‰¤ ğ‘˜ < ğ‘— âˆ’ ğ‘–.

,

A truncation function that outputs the leftmost â„“ bytes of the input
byte string ğ‘‹.  If ğ‘Œ  =  Truncâ„“(ğ‘‹), then ğ‘Œ is a byte string (array) of
length â„“ such that ğ‘Œ [ğ‘–] = ğ‘‹[ğ‘–] for 0 â‰¤ ğ‘– < â„“ (i.e., ğ‘Œ  = ğ‘‹[0 âˆ¶ â„“]).

The length (in bytes) of byte string ğ‘‹.

The ceiling of ğ‘; the smallest integer that is greater than or equal to ğ‘.
For example, âŒˆ5âŒ‰ = 5, âŒˆ5.3âŒ‰ = 6, and âŒˆâˆ’2.1âŒ‰ = âˆ’2. [1]

The floor of ğ‘; the largest integer that is less than or equal to ğ‘. For
example, âŒŠ5âŒ‹ = 5, âŒŠ5.3âŒ‹ = 5, and âŒŠâˆ’2.1âŒ‹ = âˆ’3. [1]

ğ‘ mod ğ‘›

The unique remainder ğ‘Ÿ, 0 â‰¤ ğ‘Ÿ â‰¤ (ğ‘› âˆ’ 1), when integer ğ‘ is divided
by the positive integer ğ‘›. For example, 23 mod 7 = 2. [1]

ğ‘ â‹… ğ‘

ğ‘ğ‘

log2 ğ‘¥
0b

0x

ğ‘ â‰« ğ‘

The product of ğ‘ and ğ‘. For example, 3 â‹… 5 = 15.

ğ‘ raised to the power ğ‘. For example, 25  = 32.
The base 2 logarithm of ğ‘¥. For example, log2(16) = 4.
The prefix to a number that is represented in binary.

The prefix to a number that is represented in hexadecimal. [1, adapted]

The logical right shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰« ğ‘ = âŒŠğ‘/2 âŒ‹). For
example, 0x73 â‰« 4 = 7. [10, adapted]

ğ‘

5

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

ğ‘ â‰ª ğ‘

ğ‘ âŠ• ğ‘

ğ‘  â† ğ‘¥

$

ğ‘  â†âˆ’ ğ”¹ğ‘›

The logical left shift of ğ‘ by ğ‘ positions (i.e., ğ‘  â‰ª  ğ‘  =  ğ‘ â‹… 2ğ‘).  For
example, 0x73 â‰ª 4 = 0x730. [10, adapted]

The bitwise exclusive-or of ğ‘ and ğ‘.  For example, 115 âŠ• 1  =  114
(115 âŠ• 1 = 0b01110011 âŠ• 0b00000001 = 0b01110010 = 114).

In pseudocode, this notation means that the variable ğ‘  is set to the
value of the expression ğ‘¥.

In pseudocode, this notation means that the variable ğ‘  is set to a
byte string of length ğ‘› chosen at random.  A fresh random value is
generated for each time this step is performed.

âŠ¥

A symbol indicating failure or the lack of output from an algorithm.

6

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

3.  Overview  of  the  SLH-DSA  Signature  Scheme

SLH-DSA is a stateless hash-based signature scheme that is constructed using other hash-based
signature schemes as components: (1) a few-time signature scheme, forest of random subsets
(FORS), and (2) a multi-time signature scheme, the eXtended Merkle Signature Scheme (XMSS).
XMSS is constructed using the hash-based one-time signature scheme Winternitz One-Time
2
Signature Plus (WOTS+) as a component.

Conceptually, an SLH-DSA key pair consists of a very large set of FORS key pairs.3
The few-time
signature scheme FORS allows each key pair to safely sign a small number of messages.  An
SLH-DSA signature is created by computing a randomized hash of the message, using part of the
resulting message digest to pseudorandomly select a FORS key, and signing the remaining part of
the message digest with that key. An SLH-DSA signature consists of the FORS signature and the
information that authenticates the FORS public key. The authentication information is created
using XMSS signatures.

XMSS is a multi-time signature scheme that is created using a combination of WOTS+  one-time
signatures and Merkle hash trees [13]. An XMSS key consists of 2â„â€²  WOTS+  keys and can sign
2â„â€²  messages. The WOTS+  public keys are formed into a Merkle hash tree, and the root of the
tree is the XMSS public key. (The Merkle hash tree formed from the WOTS+  keys is also referred
to as an XMSS tree.) An XMSS signature consists of a WOTS+  signature and an authentication
path within the Merkle hash tree for the WOTS+  public key.  In Figure 1, triangles represent
XMSS trees, squares represent the WOTS+  public keys, and circles represent the interior nodes
of the hash tree.  Within an XMSS tree, the square and circles that are filled in represent the
authentication path for the WOTS+  public key needed to verify the signature.

The authentication information for a FORS public key is a hypertree signature. A hypertree is a
tree of XMSS trees, as depicted in Figure 1. The tree consists of ğ‘‘ layers4
in which the top layer
(layer ğ‘‘ âˆ’ 1) consists of a single XMSS tree, the next layer down (layer ğ‘‘ âˆ’ 2) consists of 2â„â€²
XMSS trees, and the lowest layer (layer 0) consists of 2(ğ‘‘âˆ’1)â„â€²  XMSS trees. The public key of each
XMSS key at layers 0 through ğ‘‘ âˆ’ 2 is signed by an XMSS key at the next higher layer. The XMSS
keys at layer 0 collectively have 2ğ‘‘â„â€²  =  2â„  WOTS+  keys, which are used to sign the 2â„  FORS
public keys in the SLH-DSA key pair. The sequence of ğ‘‘ XMSS signatures needed to authenticate
a FORS public key when starting with the public key of the XMSS key at layer ğ‘‘ âˆ’ 1 is a hypertree
signature. An SLH-DSA signature consists of a FORS signature along with a hypertree signature.

An SLH-DSA public key (Figure 16) contains two ğ‘›-byte components: (1) PK.root, which is the
public key of the XMSS key at layer ğ‘‘ âˆ’ 1, and (2) PK.seed, which is used to provide domain
separation between different SLH-DSA key pairs. An SLH-DSA private key (Figure 15) consists of
an ğ‘›-byte seed SK.seed that is used to pseudorandomly generate all of the secret values for the
WOTS+ and FORS keys and an ğ‘›-byte key SK.prf that is used in the generation of the randomized
hash of the message. An SLH-DSA private key also includes copies of PK.root and PK.seed, as
these values are needed during both signature generation and signature verification.

2The WOTS+  and XMSS schemes that are used as components of SLH-DSA are not the same as the WOTS+  and
XMSS schemes in RFC 8391 [11] and SP 800-208 [12].
3For the parameter sets in this standard, an SLH-DSA key pair contains 263
pseudorandomly generated from a single seed.
4For the parameter sets in this standard, ğ‘‘ is 7, 8, 17, or 22.

, or 268  FORS keys, which are

, 264 , 266

7

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

PK.root

layer ğ‘‘ âˆ’ 1 = 2

WOTS+  signature

layer 1

WOTS+  signature

layer 0

WOTS+  signature

FORS signature

Message

Merkle tree node
WOTS+  public key

FORS public key

Figure 1. An SLH-DSA signature

The WOTS+  one-time signature scheme is specified in Section 5, and the XMSS multi-time sig-
nature scheme is specified in Section 6. Section 7 specifies the generation and verification of
hypertree signatures.  The FORS few-time signature scheme is specified in Section 8.  Finally,
Section 9 specifies the SLH-DSA key generation, signature, and verification functions.  As the
WOTS+ , XMSS, hypertree, and FORS schemes described in this standard are not intended for
use as stand-alone signature schemes, only the components of the schemes necessary to imple-
ment SLH-DSA are described. In particular, these sections do not include functions for key pair
generation, and a signature verification function is only specified for hypertree signatures.

When used in this standard, WOTS+ , XMSS, and FORS signatures are implicitly verified using
functions to generate public keys from messages and signatures (see Sections 5.3, 6.3, and
8.4). When verifying an SLH-DSA signature, the randomized hash of the message and the FORS
signature are used to compute a candidate FORS public key. The candidate FORS public key and
the WOTS+  signature from the layer 0 XMSS key are used to compute a candidate WOTS+  public
key, which is then used in conjunction with the corresponding authentication path to compute a
candidate XMSS public key. The candidate layer 0 XMSS public key is used along with the layer 1

8

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

XMSS signature to compute a candidate layer 1 XMSS public key. This process is repeated until a
candidate layer ğ‘‘ âˆ’ 1 public key has been computed. SLH-DSA signature verification succeeds if
the computed candidate layer ğ‘‘ âˆ’ 1 XMSS public key is the same as the SLH-DSA public key root
PK.root.

3.1  Additional  Requirements

This section specifies requirements for cryptographic modules that implement SLH-DSA. Sec-
tion 3.2 discusses issues that implementers of cryptographic modules should take into considera-
tion but that are not requirements. SP 800-89, Recommendation for Obtaining Assurances for
Digital Signature Applications [3], specifies requirements that apply to the use of digital signature
schemes.

Randomness generation. SLH-DSA key generation (Algorithm 21) requires the generation of three
random ğ‘›-byte values: PK.seed, SK.seed, and SK.prf, where ğ‘› is 16, 24, or 32, depending on
the parameter set. For each invocation of key generation, each of these values shall be a fresh
(i.e., not previously used) random value generated using an approved random bit generator
(RBG), as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [14, 15, 16]. Moreover, the RBG
used shall have a security strength of at least 8ğ‘› bits.  See Table 2 for the value of ğ‘› for each
parameter set.

Destruction of sensitive data. Data used internally by key generation and signing algorithms in
intermediate computation steps could be used by an adversary to gain information about the
private key and thereby compromise security. The data used internally by verification algorithms
is similarly sensitive for some applications, including the verification of signatures that are used as
bearer tokens (i.e., authentication secrets) or signatures on plaintext messages that are intended
to be confidential.  Intermediate values of the verification algorithm may reveal information
about its inputs (i.e., the message, signature, and public key), and in some applications, security
or privacy requires one or more of these inputs to be confidential. Therefore, implementations of
SLH-DSA shall ensure that any local copies of the inputs and any potentially sensitive intermediate
data are destroyed as soon as they are no longer needed.

Key checks. SP 800-89 imposes requirements for the assurance of public-key validity and private-
key possession. In the case of SLH-DSA, where public-key validation is required, implementations
shall verify that the public key is 2ğ‘› bytes in length. When the assurance of private key possession
is obtained via regeneration, the owner of the private key shall check that the private key is 4ğ‘›
bytes in length and shall use SK.seed and PK.seed to recompute PK.root and compare the
newly generated value with the value in the private key currently held.

Floating-point arithmetic. Implementations of SLH-DSA shall not use floating-point arithmetic,
as rounding errors in floating point operations may lead to incorrect results in some cases. In all
pseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide ğ‘¥,
either âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used. Both of these can be computed without floating-point arithmetic,
as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative
integers ğ‘¥ and positive integers ğ‘¦.

9

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

While the value of ğ‘™ğ‘’ğ‘›2  (see Equation 5.3) may be computed without using floating-point arith-
metic (see Algorithm 1), it is recommended that this value be precomputed. For all parameter
sets in this standard, ğ‘™ğ‘’ğ‘›2  is 3.

ğ‘™ğ‘”ğ‘¤

ğ‘™ğ‘’ğ‘›1  â† âŒŠ 8â‹…ğ‘›+ğ‘™ğ‘”ğ‘¤âˆ’1
âŒ‹

Algorithm 1 gen_len2(ğ‘›, ğ‘™ğ‘”ğ‘¤)
Computes ğ‘™ğ‘’ğ‘›2  (Equation 5.3).
Input: Security parameter ğ‘›, bits per hash chain ğ‘™ğ‘”ğ‘¤.
Output: ğ‘™ğ‘’ğ‘›2.
1:  ğ‘¤ â† 2ğ‘™ğ‘”ğ‘¤
2:
3:  ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š = ğ‘™ğ‘’ğ‘›1  â‹… (ğ‘¤ âˆ’ 1)
4:  ğ‘™ğ‘’ğ‘›2  â† 1
5:  ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘¤
6:  while ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‰¤ ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š do
7:
8:
9:  end while
10:  return ğ‘™ğ‘’ğ‘›2

ğ‘™ğ‘’ğ‘›2  â† ğ‘™ğ‘’ğ‘›2  + 1
ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‹… ğ‘¤

â–· Equation 5.1
â–· Equation 5.2
â–· maximum possible checksum value

â–· maximum value that may be signed using
â–· ğ‘™ğ‘’ğ‘›2  hash chains is ğ‘¤ğ‘™ğ‘’ğ‘›2  âˆ’ 1 = ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ âˆ’ 1

3.2

Implementation  Considerations

This section discusses some implementation considerations for SLH-DSA.

Do not support component use. As WOTS+ , XMSS, FORS, and hypertree signature schemes are
not approved for use as stand-alone signature schemes, cryptographic modules should not make
interfaces to these components available to applications. SP 800-208 [12] specifies approved
stateful hash-based signature schemes.

Side-channel and fault attacks. For signature schemes, the secrecy of the private key is critical.
Care must be taken to protect implementations against attacks, such as side-channel attacks
or fault attacks [17, 18, 19, 20, 21]. A cryptographic device may leak critical information with
side-channel analysis or attacks that allow internal data or keying material to be extracted without
breaking the cryptographic primitives.

10

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

4.  Functions  and  Addressing

4.1  Hash  Functions  and  Pseudorandom  Functions

The specification of SLH-DSA makes use of six functions â€” PRFğ‘šğ‘ ğ‘”, Hğ‘šğ‘ ğ‘”, PRF, Tâ„“, H, and
F â€” that are all implemented using hash functions or XOFs with fixed output lengths. The inputs
and output of each function are byte strings.  In the following definitions, ğ”¹  =  {0, â€¦ , 255}
denotes the set of all bytes, ğ”¹ğ‘› denotes the set of byte strings of length ğ‘› bytes, and ğ”¹âˆ— denotes
the set of all byte strings. The ADRS input is described in Section 4.2.

â€¢  PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) (ğ”¹ğ‘›  Ã— ğ”¹ğ‘›  Ã— ğ”¹âˆ—  â†’  ğ”¹ğ‘›) is a pseudorandom function
(PRF) that generates the randomizer (ğ‘…) for the randomized hashing of the message to be
signed.

â€¢  Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) (ğ”¹ğ‘›  Ã— ğ”¹ğ‘›  Ã— ğ”¹ğ‘›  Ã— ğ”¹âˆ—  â†’ ğ”¹ğ‘š) is used to generate the

digest of the message to be signed.

â€¢  PRF(PK.seed, SK.seed, ADRS) (ğ”¹ğ‘›  Ã— ğ”¹ğ‘›  Ã— ğ”¹32  â†’  ğ”¹ğ‘›) is a PRF that is used to

generate the secret values in WOTS+  and FORS private keys.

â€¢  Tâ„“(PK.seed, ADRS, ğ‘€â„“) (ğ”¹ğ‘›  Ã— ğ”¹32  Ã— ğ”¹â„“ğ‘›  â†’  ğ”¹ğ‘›) is a hash function that maps an

â„“ğ‘›-byte message to an ğ‘›-byte message.

â€¢  H(PK.seed, ADRS, ğ‘€2) (ğ”¹ğ‘›  Ã— ğ”¹32  Ã— ğ”¹2ğ‘›  â†’ ğ”¹ğ‘›) is a special case of Tâ„“  that takes a

2ğ‘›-byte message as input.

â€¢  F(PK.seed, ADRS, ğ‘€1) (ğ”¹ğ‘› Ã— ğ”¹32 Ã— ğ”¹ğ‘›  â†’ ğ”¹ğ‘›) is a hash function that takes an ğ‘›-byte

message as input and produces an ğ‘›-byte output.

The specific instantiations for these functions differ for different parameter sets and are specified
in Section 11.

4.2  Addresses

Four of the functions described in Section 4.1 take a 32-byte address (i.e., ADRS) as input. An
ADRS consists of public values that indicate the position of the value being computed by the
function. A different ADRS value is used for each call to each function. In the case of PRF,
this is used to generate a large number of different secret values from a single seed. In the case
of Tâ„“, H, and F, it is used to mitigate multi-target attacks. In the pseudocode, where addresses
are passed as parameters, they may be passed either by reference or by value.

The structure of an ADRS conforms to word boundaries, with each word being 4 bytes long
and values encoded as unsigned integers in big-endian byte order (see Figure 2). The first word
of ADRS specifies the layer address, which is the height of an XMSS tree within the hypertree.
Trees on the bottom layer have a height of zero, and the single XMSS tree at the top has a height
of ğ‘‘ âˆ’ 1 (see Figure 1). The next three words of ADRS specify the tree address, which is the
position of an XMSS tree within a layer of the hypertree. The leftmost XMSS tree in a layer has a
tree address of zero, and the rightmost XMSS tree in layer ğ¿ has a tree address of 2(ğ‘‘âˆ’1âˆ’ğ¿)â„â€²  âˆ’ 1.
The next word is used to specify the type of the address, which differs depending on the use case.

11

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

There are seven different types of address used in SLH-DSA, as described below.5
The address
type determines how the final 12 bytes of the address are to be interpreted.  The algorithms
in this standard are written based on the assumption that whenever the type in an ADRS is
changed, the final 12 bytes of the address are initialized to zero.

layer address

4 bytes

tree address

12 bytes

ğ‘¡ğ‘¦ğ‘ğ‘’

4 bytes

12 bytes

Figure 2. Address (ADRS)

The type is set to WOTS_HASH (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 0) for a WOTS+  hash address (see Figure 3), which is
used when computing hash chains in WOTS+ . When type is WOTS_HASH, the next word encodes
the key pair address, which is the index of the WOTS+  key pair within the XMSS tree specified
by the layer and tree addresses, with the leftmost WOTS+  key having an index of zero and the
rightmost WOTS+  key having an index of 2â„â€²  âˆ’ 1. Next is the chain address, which encodes the
index of the chain within WOTS+ , followed by the hash address, which encodes the address of
the hash function within the chain.

layer address

tree address

layer address

tree address

ğ‘¡ğ‘¦ğ‘ğ‘’ = 0 (WOTS_HASH)
key pair address
chain address
hash address

4 bytes
4 bytes
4 bytes

ğ‘¡ğ‘¦ğ‘ğ‘’ = 1 (WOTS_PK)
key pair address

ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0

4 bytes

8 bytes

Figure 3.

WOTS hash address

+

Figure 4.

WOTS public-key compression address

+

The type is set to WOTS_PK (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 1) when compressing WOTS+  public keys (see Figure 4).
As when the type is WOTS_HASH, the next word encodes the index of the WOTS+  key pair within
the XMSS tree specified by the layer and tree addresses. The remaining two words of ADRS
are not needed and are set to zero.

The type is set to TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 2) when computing the hashes within the XMSS tree (see
Figure 5).  For this type of address, the next word is always set to zero.  The following word

5The type word will have a value of 0, 1, 2, 3, 4, 5, or 6.  In order to improve readability, these values will be
referred to in this standard by the constants WOTS_HASH, WOTS_PK, TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF,
and FORS_PRF, respectively.

12

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

encodes the height of the node within the tree that is being computed, and the final word
encodes the index of the node at that height.

layer address

tree address

ğ‘¡ğ‘¦ğ‘ğ‘’ = 2 (TREE)
ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0
tree height
tree index

4 bytes
4 bytes
4 bytes

Figure 5. Hash tree address

The type is set to FORS_TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 3) when computing hashes within the FORS tree (see
Figure 6). The next word is the key pair address, which encodes the FORS key that is used. The
value is the same as the key pair address for the WOTS+  key used to sign the FORS key (see
Figure 3 and Figure 4). The next two words â€” the tree height and tree index â€” encode the node
within the FORS tree that is being computed. The tree height starts with zero for the leaf nodes.
The tree index is counted continuously across the ğ‘˜ different FORS trees. The leftmost node in
the leftmost tree has an index of zero, and the rightmost node in the rightmost tree at level ğ‘—
has an index of ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘—)  âˆ’ 1, where ğ‘ is the height of the tree.

layer address = 0

tree address

layer address = 0

tree address

ğ‘¡ğ‘¦ğ‘ğ‘’ = 3 (FORS_TREE)
key pair address
tree height
tree index

4 bytes
4 bytes
4 bytes

ğ‘¡ğ‘¦ğ‘ğ‘’ = 4 (FORS_ROOTS)
key pair address

ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0

4 bytes

8 bytes

Figure 6. FORS tree address

Figure 7. FORS tree roots compression address

The type is set to FORS_ROOTS (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’  =  4) when compressing the ğ‘˜ FORS tree roots (see
Figure 7). The next word is the key pair address, which has the same meaning as it does in the
FORS_TREE address. The remaining two words of ADRS are not needed and are set to zero.
The type is set to WOTS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 5) when generating secret values for WOTS+  keys (see
Figure 8). The values for the other words in the address are set to the same values as for the
WOTS_HASH address (Figure 3) used for the chain. The hash address is always set to zero.

13

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

layer address

tree address

layer address = 0

tree address

ğ‘¡ğ‘¦ğ‘ğ‘’ = 5 (WOTS_PRF)
key pair address
chain address
hash address = 0

4 bytes
4 bytes
4 bytes

ğ‘¡ğ‘¦ğ‘ğ‘’ = 6 (FORS_PRF)
key pair address
tree height = 0
tree index

4 bytes
4 bytes
4 bytes

Figure 8.

WOTS key generation address

+

Figure 9. FORS key generation address

The type is set to FORS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 6) when generating secret values for FORS keys (see
Figure 9). The values for the other words in the address are set to the same values as for the
FORS_TREE address (Figure 6) used for the same leaf node.

4.3  Member  Functions

The algorithms in this standard make use of member functions.  If a complex data structure
(e.g., an ADRS) contains a component ğ‘‹, then ADRS.getX() returns the value of ğ‘‹, and
ADRS.setX(ğ‘Œ) sets the component ğ‘‹ in ADRS to the value held by ğ‘Œ. If a data structure ğ‘ 
contains multiple instances of ğ‘‹, then ğ‘ .getX(ğ‘–) returns the value of the ğ‘–th  instance of ğ‘‹ in ğ‘ .
For example, if ğ‘  is a FORS signature (Figure 14), then ğ‘ .getAUTH(ğ‘–) returns the authentication
path for the ğ‘–th  tree.

Whenever the type in an address changes, the final 12 bytes of the address are initialized to zero.
The member function ADRS.setTypeAndClear(ğ‘Œ) for addresses sets the ğ‘¡ğ‘¦ğ‘ğ‘’ of the ADRS to
6
ğ‘Œ and sets the final 12 bytes of the ADRS to zero.

Table 1 shows alternative notation for each of the member functions that operates on addresses.

Table 1. Member functions for addresses

Member function
ADRS.setLayerAddress(ğ‘™)
ADRS.setTreeAddress(ğ‘¡)
ADRS.setTypeAndClear(ğ‘Œ)
ADRS.setKeyPairAddress(ğ‘–)
ADRS.setChainAddress(ğ‘–)
ADRS.setTreeHeight(ğ‘–)
ADRS.setHashAddress(ğ‘–)
ADRS.setTreeIndex(ğ‘–)
ğ‘– â† ADRS.getKeyPairAddress()
ğ‘– â† ADRS.getTreeIndex()

Expanded notation
ADRS â† toByte(ğ‘™, 4) âˆ¥ ADRS[4 âˆ¶ 32]
ADRS â† ADRS[0 âˆ¶ 4] âˆ¥ toByte(ğ‘¡, 12) âˆ¥ ADRS[16 âˆ¶ 32]
ADRS â† ADRS[0 âˆ¶ 16] âˆ¥ toByte(ğ‘Œ , 4) âˆ¥ toByte(0, 12)
ADRS â† ADRS[0 âˆ¶ 20] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[24 âˆ¶ 32]

ADRS â† ADRS[0 âˆ¶ 24] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[28 âˆ¶ 32]

ADRS â† ADRS[0 âˆ¶ 28] âˆ¥ toByte(ğ‘–, 4)

ğ‘– â† toInt(ADRS[20 âˆ¶ 24], 4)
ğ‘– â† toInt(ADRS[28 âˆ¶ 32], 4)

6As noted in Section 4.2, the type (ğ‘Œ) is an integer. However, in the pseudocode, the constants WOTS_HASH, WOTS_PK,
TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF, and FORS_PRF are used in order to improve readability.

14

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

4.4  Arrays,  Byte  Strings,  and  Integers

If ğ‘‹ is a byte string of length ğ‘›, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘› âˆ’ 1} will refer to the ğ‘–th  element in
the string ğ‘‹. If ğ‘‹ is an array of ğ‘š ğ‘›-byte strings, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘š âˆ’ 1} will refer to
the ğ‘–th  ğ‘›-byte string in ğ‘‹, and ğ‘‹ will refer to the ğ‘š â‹… ğ‘›-byte string ğ‘‹[0] âˆ¥ ğ‘‹[1] âˆ¥ â€¦ ğ‘‹[ğ‘š âˆ’ 1].

A byte string may be interpreted as the big-endian representation of an integer. In such cases, a
byte string ğ‘‹ of length ğ‘› is converted to the integer

ğ‘‹[0] â‹… 256ğ‘›âˆ’1  + ğ‘‹[1] â‹… 256ğ‘›âˆ’2  + â€¦ ğ‘‹[ğ‘› âˆ’ 2] â‹… 256 + ğ‘‹[ğ‘› âˆ’ 1].

Similarly, an integer ğ‘¥ may be converted to a byte string of length ğ‘› by finding coefficients
ğ‘¥0, ğ‘¥1, â€¦ ğ‘¥ğ‘›âˆ’2, ğ‘¥ğ‘›âˆ’1  âˆˆ {0, â€¦ , 255} such that

ğ‘¥ = ğ‘¥0  â‹… 256ğ‘›âˆ’1  + ğ‘¥1  â‹… 256ğ‘›âˆ’2  + â€¦ ğ‘¥ğ‘›âˆ’2  â‹… 256 + ğ‘¥ğ‘›âˆ’1

and then setting the byte string to be ğ‘¥0ğ‘¥1 â€¦ ğ‘¥ğ‘›âˆ’2ğ‘¥ğ‘›âˆ’1.
Algorithm 2 is a function that converts a byte string ğ‘‹ of length ğ‘› to an integer, and Algorithm 3
is a function that converts an integer ğ‘¥ to a byte string of length ğ‘›.

Algorithm 2 toInt(ğ‘‹, ğ‘›)
Converts a byte string to an integer.
Input: ğ‘›-byte string ğ‘‹.
Output: Integer value of ğ‘‹.

1:  ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0

ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 256 â‹… ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ + ğ‘‹[ğ‘–]

2:  for ğ‘– from 0 to ğ‘› âˆ’ 1 do
3:
4:  end for
5:  return ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™

Algorithm 3 toByte(ğ‘¥, ğ‘›)
Converts an integer to a byte string.
Input: Integer ğ‘¥, string length ğ‘›.
Output: Byte string of length ğ‘› containing binary representation of ğ‘¥ in big-endian byte-order.

1:  ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¥

ğ‘†[ğ‘› âˆ’ 1 âˆ’ ğ‘–] â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ mod 256
ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« 8

2:  for ğ‘– from 0 to ğ‘› âˆ’ 1 do
3:
4:
5:  end for
6:  return ğ‘†

15

â–· least significant 8 bits of ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

For the WOTS+  and FORS schemes, the messages to be signed need to be split into a sequence
of ğ‘-bit strings, where each ğ‘-bit string is interpreted as an integer between 0 and 2ğ‘  âˆ’ 1. 7
This
is the equivalent of creating the base-2ğ‘  representation of the message. The base_2b  function
(Algorithm 4) takes a byte string ğ‘‹, a bit string length ğ‘, and an output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› as input
and returns an array of base-2ğ‘  integers that represent the first ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘ bits of ğ‘‹ if the
individual bytes in ğ‘‹ are encoded as 8-bit strings in big-endian bit order.  ğ‘‹ must be at least
âŒˆğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘/8âŒ‰ bytes in length. As the value of ğ‘ğ‘–ğ‘¡ğ‘  will never exceed ğ‘ + 7, a ğ‘ + 7-bit unsigned
integer is sufficient to store ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ (i.e., ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ may be stored as a 32-bit unsigned integer).

Algorithm 4 base_2b(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)
Computes the base 2ğ‘  representation of ğ‘‹.
Input: Byte string ğ‘‹ of length at least âŒˆ ğ‘œğ‘¢ğ‘¡_
ğ‘™ğ‘’ğ‘›â‹…ğ‘ âŒ‰, integer ğ‘, output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›.
8
Output: Array of ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› integers in the range [0, â€¦ , 2ğ‘  âˆ’ 1].
1:  ğ‘–ğ‘› â† 0
2:  ğ‘ğ‘–ğ‘¡ğ‘  â† 0
3:  ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0

while ğ‘ğ‘–ğ‘¡ğ‘  < ğ‘ do

ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰ª 8) + ğ‘‹[ğ‘–ğ‘›]
ğ‘–ğ‘› â† ğ‘–ğ‘› + 1
ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  + 8

4:  for ğ‘œğ‘¢ğ‘¡ from 0 to ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› âˆ’ 1 do
5:
6:
7:
8:
9:
10:
11:
12:  end for
13:  return ğ‘ğ‘ğ‘ ğ‘’ğ‘

end while
ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  âˆ’ ğ‘
ğ‘ğ‘ğ‘ ğ‘’ğ‘[ğ‘œğ‘¢ğ‘¡] â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« ğ‘ğ‘–ğ‘¡ğ‘ ) mod 2ğ‘

7ğ‘ will be the value of ğ‘™ğ‘”ğ‘¤  when the base_2b  function is used in WOTS  , and ğ‘ will be the value of ğ‘ when the
base_2b  function is used in FORS. For the parameter sets in this standard, ğ‘™ğ‘”ğ‘¤  is 4, and ğ‘ is 6, 8, 9, 12, or 14.
16

+

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

5.  Winternitz  One-Time  Signature  Plus  Scheme

This section describes the WOTS+  one-time signature scheme that is a component of SLH-DSA.

WOTS+  uses two parameters. The security parameter ğ‘› is the length in bytes of the messages
that may be signed as well as the length of the private key elements, public key elements, and
signature elements. For the parameter sets specified in this standard, ğ‘› may be 16, 24, or 32
(see Table 2). The second parameter ğ‘™ğ‘”ğ‘¤  indicates the number of bits that are encoded by each
hash chain that is used.8
ğ‘™ğ‘”ğ‘¤  is 4 for all parameter sets in this standard. These parameters are
used to compute four additional values:

ğ‘¤ = 2ğ‘™ğ‘”ğ‘¤
8ğ‘›
ğ‘™ğ‘”ğ‘¤

= âŒˆ

ğ‘™ğ‘’ğ‘›1

âŒ‰

ğ‘™ğ‘’ğ‘›2

= âŒŠ

log2(ğ‘™ğ‘’ğ‘›1  â‹… (ğ‘¤ âˆ’ 1))
ğ‘™ğ‘”ğ‘¤

âŒ‹ + 1

ğ‘™ğ‘’ğ‘› = ğ‘™ğ‘’ğ‘›1  + ğ‘™ğ‘’ğ‘›2

(5.1)

(5.2)

(5.3)

(5.4)

When ğ‘™ğ‘”ğ‘¤  = 4, ğ‘¤ = 16, ğ‘™ğ‘’ğ‘›1  = 2ğ‘›, ğ‘™ğ‘’ğ‘›2  = 3, and ğ‘™ğ‘’ğ‘› = 2ğ‘› + 3.
A WOTS+ private key consists of ğ‘™ğ‘’ğ‘› secret values of length ğ‘›. In SLH-DSA, these are all generated
from an ğ‘›-byte seed SK.seed using a PRF. Chains of length ğ‘¤ are then created from the secret
values using a chaining function, and the end values from each of the chains are public values. The
WOTS+  public key is computed as the hash of these public values. In order to create a signature,
the 8ğ‘›-bit message is first converted into an array of ğ‘™ğ‘’ğ‘›1  base-ğ‘¤ integers. A checksum is then
computed for this string, and the checksum is converted into an array of ğ‘™ğ‘’ğ‘›2  base-ğ‘¤ integers.
The signature consists of the appropriate entries from the chains for each of the integers in the
message and checksum arrays.

The WOTS+ functions make use of two helper functions: base_2b and chain. The base_2b function
(Section 4.4) is used to break the message to be signed and the checksum value into arrays of
base-ğ‘¤ integers. The chain function (Algorithm 5) is used to compute the hash chains.

9

The chain function takes an ğ‘›-byte string ğ‘‹ and integers ğ‘  and ğ‘– (where ğ‘– + ğ‘  < ğ‘¤) as input and
returns the result of iterating a hash function F on the input ğ‘  times, starting from an index of
chain function also requires as input PK.seed, which is part of the SLH-DSA public key,
ğ‘–.  The
and an address ADRS. The type in ADRS must be set to WOTS_HASH, and the layer address,
tree address, key pair address, and chain address must be set to the address of the chain being
computed. The chain function updates the hash address in ADRS with each iteration to specify
the current position in the chain prior to ADRSâ€™s use in F.

8In [10], the Winternitz parameter ğ‘¤ is used as the second WOTS+  parameter, where ğ‘¤ indicates the length of the
hash chains that are used. This standard uses the parameter ğ‘™ğ‘”ğ‘¤  = log2(ğ‘¤) to simplify notation.
9A start index of 0 indicates the beginning of the chain.

17

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 5 chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)
Chaining function used in WOTS+ .
Input: Input string ğ‘‹, start index ğ‘–, number of steps ğ‘ , public seed PK.seed, address ADRS.
Output: Value of F iterated ğ‘  times on ğ‘‹.

1:  ğ‘¡ğ‘šğ‘ â† ğ‘‹

ADRS.setHashAddress(ğ‘—)
ğ‘¡ğ‘šğ‘ â† F(PK.seed, ADRS, ğ‘¡ğ‘šğ‘)

2:  for ğ‘— from ğ‘– to ğ‘– + ğ‘  âˆ’ 1 do
3:
4:
5:  end for
6:  return ğ‘¡ğ‘šğ‘

5.1  WOTS+  Public-Key  Generation
The wots_pkGen function (Algorithm 6) generates WOTS+  public keys.  It takes SK.seed and
PK.seed from the SLH-DSA private key and an address as input. The type in the address ADRS
must be set to WOTS_HASH, and the layer address, tree address, and key pair address must encode
the address of the WOTS+  public key to be generated.

Lines 4 through 9 in Algorithm 6 generate the public values, as described in Section 5. For each
of the ğ‘™ğ‘’ğ‘› public values, the corresponding secret value is generated in lines 5 and 6, and the
chain function is called to compute the end value of the chain of length ğ‘¤. Once the ğ‘™ğ‘’ğ‘› public
values are computed, they are compressed into a single ğ‘›-byte value in lines 10 through 13.

â–· copy address to create key generation key address

Algorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS)
Generates a WOTS+  public key.
Input: Secret seed SK.seed, public seed PK.seed, address ADRS.
Output: WOTS+  public key ğ‘ğ‘˜.
1:  skADRS â† ADRS
2:  skADRS.setTypeAndClear(WOTS_PRF)
3:  skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
4:  for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do
5:
6:
7:
8:
9:  end for
10:  wotspkADRS â† ADRS
11:  wotspkADRS.setTypeAndClear(WOTS_PK)
12:  wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
13:  ğ‘ğ‘˜ â† Tğ‘™ğ‘’ğ‘›(PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)
14:  return ğ‘ğ‘˜

skADRS.setChainAddress(ğ‘–)
ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)
ADRS.setChainAddress(ğ‘–)
ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘¤ âˆ’ 1, PK.seed, ADRS) â–· compute public value for chain ğ‘–

â–· compute secret value for chain ğ‘–

â–· copy address to create WOTS+public key address

â–· compress public key

18

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

5.2  WOTS+  Signature  Generation
A WOTS+ signature is an array of ğ‘™ğ‘’ğ‘› byte strings of length ğ‘›, as shown in Figure 10. The wots_sign
function (Algorithm 7) generates the signature by converting the ğ‘›-byte message ğ‘€10
into an
array of ğ‘™ğ‘’ğ‘›1  base-ğ‘¤ integers (line 2). A checksum is computed over ğ‘€ (lines 3 through 5). The
checksum is converted to a byte string, which is then converted into an array of ğ‘™ğ‘’ğ‘›2  base-ğ‘¤
integers (lines 6 and 7). The ğ‘™ğ‘’ğ‘›2 integers that represent the checksum are appended to the ğ‘™ğ‘’ğ‘›1
integers that represent the message (line 7).11
For each of the ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers, the signature
consists of the corresponding node in one of the hash chains. For each of these integers, lines
12 and 13 compute the secret value for the hash chain, and lines 14 and 15 compute the node in
the hash chain that corresponds to the integer. The selected nodes are concatenated to form
the WOTS+  signature.

sig [0]
ots
â‹¯
sig [ğ‘™ğ‘’ğ‘› âˆ’ 1]

ots

ğ‘› bytes

ğ‘› bytes

Figure 10. WOTS

+  signature data format

In addition to the ğ‘›-byte message to be signed, wots_sign takes SK.seed and PK.seed from
the SLH-DSA private key and an address as input. The type in the address ADRS must be set to
WOTS_HASH, and the layer address, tree address, and key pair address must encode the address
of the WOTS+  key that is used to sign the message.

10In SLH-DSA, the message ğ‘€ that is signed using WOTS+  is either an XMSS public key or a FORS public key.
11In the case that ğ‘™ğ‘”ğ‘¤  = 4, the ğ‘›-byte message is converted into an array of 2ğ‘› base-16 integers (i.e., hexadecimal
digits).  The checksum is encoded as two bytes with the least significant four bits being zeros, and the most
significant 12 bits are appended to the message as an array of three base-16 integers.

19

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 7 wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)
Generates a WOTS+  signature on an ğ‘›-byte message.
Input: Message ğ‘€, secret seed SK.seed, public seed PK.seed, address ADRS.
Output: WOTS+  signature ğ‘ ğ‘–ğ‘”.
1:  ğ‘ğ‘ ğ‘¢ğ‘š â† 0

2:  ğ‘šğ‘ ğ‘” â† base_2b(ğ‘€ , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›1)
3:  for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›1  âˆ’ 1 do
4:
5:  end for

ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]

â–· convert message to base ğ‘¤

â–· compute checksum

8

â–· copy address to create key generation key address

â–· for ğ‘™ğ‘”ğ‘¤  = 4, left shift by 4
â–· convert to base ğ‘¤

6:  ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›2  â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)
7:  ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2b (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›2â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›2)
8:  skADRS â† ADRS
9:  skADRS.setTypeAndClear(WOTS_PRF)
10:  skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
11:  for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do
12:
13:
14:
15:
16:  end for
17:  return ğ‘ ğ‘–ğ‘”

skADRS.setChainAddress(ğ‘–)
ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)
ADRS.setChainAddress(ğ‘–)
ğ‘ ğ‘–ğ‘”[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS) â–· compute chain ğ‘– signature value

â–· compute chain ğ‘– secret value

20

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

5.3  Computing  a  WOTS+  Public  Key  From  a  Signature
Verifying a WOTS+ signature involves computing a public-key value from a message and signature
value. Verification succeeds if the correct public-key value is computed, which is determined
by using the computed public-key value along with other information to compute a candidate
PK.root value and then comparing that value to the known value of PK.root from the SLH-DSA
public key.  This section describes wots_pkFromSig (Algorithm 8), a function that computes a
candidate WOTS+  public key from a WOTS+  signature and corresponding message.

In addition to an ğ‘›-byte message ğ‘€ and a ğ‘™ğ‘’ğ‘› â‹… ğ‘›-byte signature ğ‘ ğ‘–ğ‘”, which is interpreted as
an array of ğ‘™ğ‘’ğ‘› ğ‘›-byte strings, the wots_pkFromSig function takes PK.seed from the SLH-DSA
public key and an address as input. The type of the address ADRS must be set to WOTS_HASH,
and the layer address, tree address, and key pair address must encode the address of the WOTS+
key that was used to sign the message.

Lines 1 through 7 of wots_pkFromSig are the same as lines 1 through 7 of wots_sign (Algorithm 7).
Lines 8 through 11 of wots_pkFromSig compute the end nodes for each of the chains using
the signature value as the starting point and the message value to determine the number of
iterations that need to be performed to get to the end node. Finally, as with lines 10 through 13
of Algorithm 6, the computed public-key values are compressed in lines 12 through 15.

Algorithm 8 wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS)
Computes a WOTS+  public key from a message and its signature.
Input: WOTS+  signature ğ‘ ğ‘–ğ‘”, message ğ‘€, public seed PK.seed, address ADRS.
Output: WOTS+  public key ğ‘ğ‘˜ğ‘ ğ‘–ğ‘”  derived from ğ‘ ğ‘–ğ‘”.
1:  ğ‘ğ‘ ğ‘¢ğ‘š â† 0

2:  ğ‘šğ‘ ğ‘” â† base_2b(ğ‘€ , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›1)
3:  for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›1  âˆ’ 1 do
4:
5:  end for

ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]

â–· convert message to base ğ‘¤

â–· compute checksum

â–· for ğ‘™ğ‘”ğ‘¤  = 4, left shift by 4
â–· convert to base ğ‘¤

8

ADRS.setChainAddress(ğ‘–)
ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘–ğ‘”[ğ‘–], ğ‘šğ‘ ğ‘”[ğ‘–], ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS)

6:  ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›2  â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)
7:  ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2b (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›2â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›2)
8:  for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do
9:
10:
11:  end for
12:  wotspkADRS â† ADRS
13:  wotspkADRS.setTypeAndClear(WOTS_PK)
14:  wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
15:  ğ‘ğ‘˜ğ‘ ğ‘–ğ‘”  â† Tğ‘™ğ‘’ğ‘›(PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)
16:  return ğ‘ğ‘˜ğ‘ ğ‘–ğ‘”

â–· copy address to create WOTS+  public key address

21

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

6.  eXtended  Merkle  Signature  Scheme  (XMSS)

XMSS extends the WOTS+  signature scheme into one that can sign multiple messages. A Merkle
tree [13] of height â„â€²  is used to allow 2â„â€²  WOTS+  public keys to be authenticated using a single
ğ‘›-byte XMSS public key, which is the root of the Merkle tree.12
As each WOTS+  key may be used
to sign one message, the XMSS key may be used to sign 2â„â€²  messages.

An XMSS signature is (â„â€²  + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a WOTS+  signature and an
authentication path (see Figure 11). The authentication path is an array of nodes from the Merkle
tree â€” one from each level of the tree, except for the root â€” that allows the verifier to compute
the root of the tree when used in conjunction with the WOTS+  public key that can be computed
from the WOTS+  signature.

SIGWOTS

+

AUTH[0]
â‹¯
AUTH[â„â€²  âˆ’ 1]

ğ‘™ğ‘’ğ‘› â‹… ğ‘›
bytes
ğ‘› bytes

ğ‘› bytes

Figure 11. XMSS signature data format

6.1  Generating  a  Merkle  Hash  Tree

The xmss_node function (Algorithm 9) computes the nodes of an XMSS tree.  The xmss_node
function takes as input SK.seed and PK.seed from the SLH-DSA private key; a target node index
ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which is the height
within the Merkle tree of the node being computed; and an address. The address ADRS must
have the layer address and tree address set to the XMSS tree within which the node is being
computed. The target node height and index must satisfy ğ‘§ â‰¤ â„â€²  and ğ‘– < 2(â„â€²âˆ’ğ‘§).

Each node in an XMSS tree is the root of a subtree, and Algorithm 9 computes the root of the
subtree recursively. If the subtree consists of a single leaf node, then the function simply returns
the value of the nodeâ€™s WOTS+  public key (lines 2 through 4). Otherwise, the function computes
the roots of the left subtree (line 6) and right subtree (line 7) and hashes them together (lines 8
through 11).

12The Merkle tree formed from the 2â„â€²  WOTS+  keys of an XMSS key is referred to in this standard as an XMSS tree.
22

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 9 xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)
Computes the root of a Merkle subtree of WOTS+  public keys.
Input: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,

address ADRS.

Output: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.

ADRS.setTypeAndClear(WOTS_HASH)
ADRS.setKeyPairAddress(ğ‘–)
ğ‘›ğ‘œğ‘‘ğ‘’ â† wots_pkGen(SK.seed, PK.seed, ADRS)

ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)
ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)
ADRS.setTypeAndClear(TREE)
ADRS.setTreeHeight(ğ‘§)
ADRS.setTreeIndex(ğ‘–)
ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)

1:  if ğ‘§ = 0 then
2:
3:
4:
5:  else
6:
7:
8:
9:
10:
11:
12:  end if
13:  return ğ‘›ğ‘œğ‘‘ğ‘’

6.2  Generating  an  XMSS  Signature
The xmss_sign function (Algorithm 10) creates an XMSS signature on an ğ‘›-byte message ğ‘€13
by
creating an authentication path (lines 1 through 4) and signing ğ‘€ with the appropriate WOTS+
key (lines 5 through 7).  In addition to ğ‘€, xmss_sign takes SK.seed and PK.seed from the
SLH-DSA private key, an address, and an index as input. The address ADRS must have the layer
address and tree address set to the XMSS key that is being used to sign the message, and the
index ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTS+ key within the XMSS tree that will be used to sign the
message.

The authentication path consists of the sibling nodes of each node that is on the path from
the WOTS+  key used to the root. For example, in Figure 12, if the message is signed with ğ¾2,
then ğ¾2, ğ‘›1,1, and ğ‘›2,0  are the on path nodes, and the authentication path consists of ğ¾3,
ğ‘›1,0, and ğ‘›2,1. In line 2 of Algorithm 10, âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ is the on path node, and âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1 is the
authentication path node. Line 3 computes the value of the authentication path node.

13In SLH-DSA, the message ğ‘€ that is signed using XMSS is either an XMSS public key or a FORS public key.

23

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 10 xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS)
Generates an XMSS signature.
Input: ğ‘›-byte message ğ‘€, secret seed SK.seed, index ğ‘–ğ‘‘ğ‘¥, public seed PK.seed,

address ADRS.

Output: XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘†  = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH).
1:  for ğ‘— from 0 to â„â€²  âˆ’ 1 do
2:
3:
4:  end for

ğ‘˜ â† âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1
AUTH[ğ‘—] â† xmss_node(SK.seed, ğ‘˜, ğ‘—, PK.seed, ADRS)

5:  ADRS.setTypeAndClear(WOTS_HASH)
6:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)
7:  ğ‘ ğ‘–ğ‘” â† wots_sign(ğ‘€ , SK.seed, PK.seed, ADRS)
8:  SIGğ‘‹ğ‘€ğ‘†ğ‘†  â† ğ‘ ğ‘–ğ‘” âˆ¥ AUTH
9:  return SIGğ‘‹ğ‘€ğ‘†ğ‘†

â–· build authentication path

ğ‘›3,0  = H(ğ‘›2,0  âˆ¥ ğ‘›2,1)





PPPPP
P

ğ‘›2,0  = H(ğ‘›1,0  âˆ¥ ğ‘›1,1)

ğ‘›2,1  = H(ğ‘›1,2  âˆ¥ ğ‘›1,3)

@

@

@

@

ğ‘›1,0  = H(ğ¾0  âˆ¥ ğ¾1)  ğ‘›1,1  = H(ğ¾2  âˆ¥ ğ¾3)  ğ‘›1,2  = H(ğ¾4  âˆ¥ ğ¾5)  ğ‘›1,3  = H(ğ¾6  âˆ¥ ğ¾7)

ï¿½

ï¿½
ğ¾2

@

@

ğ¾3

ï¿½  @

ï¿½
ğ¾4

ï¿½

ï¿½
ğ¾6

@

@

ğ¾7

ï¿½

ï¿½

@
ğ¾1

ï¿½  @

ï¿½
ğ¾0

ï¿½

ï¿½

@
ğ¾5

Figure 12. Merkle hash tree

24

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

6.3  Computing  an  XMSS  Public  Key  From  a  Signature

Verifying an XMSS signature involves computing a public-key value from a message and a signature
value. Verification succeeds if the correct public-key value is computed, which is determined
by using the computed public-key value along with other information to compute a candidate
PK.root value and then comparing that value to the known value of PK.root from the SLH-DSA
public key. This section describes xmss_pkFromSig (Algorithm 11), a function that computes a
candidate XMSS public key from an XMSS signature and corresponding message.
In addition to an ğ‘›-byte message ğ‘€ and an (ğ‘™ğ‘’ğ‘›+â„â€²)â‹…ğ‘›-byte signature SIGğ‘‹ğ‘€ğ‘†ğ‘†, xmss_pkFromSig
takes PK.seed from the SLH-DSA public key, an address, and an index as input.  The address
ADRS must be set to the layer address and tree address of the XMSS key that was used to sign
the message, and the index ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTS+  key within the XMSS tree that
was used to sign the message.

Algorithm 11 begins by computing the WOTS+  public key in lines 1 through 5. The root is then
computed in lines 6 through 18.  Starting with the leaf node (i.e., the WOTS+  public key), a
node at each level of the tree is computed by hashing together the node computed in the
previous iteration with the corresponding authentication path node. In lines 12 and 15, AUTH is
interpreted as an array of â„â€²  ğ‘›-byte strings.

Algorithm 11 xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS)
Computes an XMSS public key from an XMSS signature.
Input: Index ğ‘–ğ‘‘ğ‘¥, XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘†  = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH), ğ‘›-byte message ğ‘€,

public seed PK.seed, address ADRS.

Output: ğ‘›-byte root value ğ‘›ğ‘œğ‘‘ğ‘’[0].
1:  ADRS.setTypeAndClear(WOTS_HASH)
2:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)
3:  ğ‘ ğ‘–ğ‘” â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getWOTSSig()
4:  AUTH â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getXMSSAUTH()
5:  ğ‘›ğ‘œğ‘‘ğ‘’[0] â† wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€ , PK.seed, ADRS)

â–· compute WOTS+  pk from WOTS+  ğ‘ ğ‘–ğ‘”

â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[0 âˆ¶ ğ‘™ğ‘’ğ‘› â‹… ğ‘›]
â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[ğ‘™ğ‘’ğ‘› â‹… ğ‘› âˆ¶ (ğ‘™ğ‘’ğ‘› + â„â€²) â‹… ğ‘›]

â–· compute root from WOTS+  pk and AUTH

ADRS.setTreeHeight(ğ‘˜ + 1)
if âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘˜âŒ‹ is even then

6:  ADRS.setTypeAndClear(TREE)
7:  ADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)
8:  for ğ‘˜ from 0 to â„â€²  âˆ’ 1 do
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:  end for
19:  return ğ‘›ğ‘œğ‘‘ğ‘’[0]

end if
ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]

else

ADRS.setTreeIndex(ADRS.getTreeIndex()/2)
ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ AUTH[ğ‘˜])

ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)
ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, AUTH[ğ‘˜] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])

25

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

7.  The  SLH-DSA  Hypertree

SLH-DSA requires a very large number of WOTS+  keys to sign FORS public keys.  As it would
not be feasible for the parameter sets in this standard to have a single XMSS key with so many
WOTS+ keys, SLH-DSA uses a hypertree to sign the FORS keys. As depicted in Figure 1, a hypertree
is a tree of XMSS trees.  The XMSS keys at the lowest layer are used to sign FORS public keys
(Section 8), and the XMSS keys at every other layer are used to sign the XMSS public keys at the
layer below.

The hypertree has ğ‘‘ layers of XMSS trees with each XMSS tree being a Merkle tree of height â„â€² ,
so the total height of the hypertree is â„ = ğ‘‘ â‹… â„â€²  (see Table 2). The top layer (layer ğ‘‘ âˆ’ 1) is a
single XMSS tree, and the public key of this XMSS key pair (i.e., the root of the Merkle tree) is the
public key of the hypertree (PK.root). The next layer down has 2â„â€²  XMSS trees, and the public
key of each of these XMSS keys is signed by one of the 2â„â€²  WOTS+  keys that is part of the top
layerâ€™s XMSS key. The lowest layer has 2â„âˆ’â„â€²  XMSS trees, providing 2â„  WOTS+  keys to sign FORS
keys.

7.1  Hypertree  Signature  Generation

A hypertree signature is (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a sequence of ğ‘‘ XMSS
signatures, starting with a signature generated using an XMSS key at the lowest layer and ending
with a signature generated using the XMSS key at the top layer (see Figure 13).

XMSS signature SIGXMSS  (layer 0)
XMSS signature SIGXMSS  (layer 1)
â‹¯
XMSS signature SIGXMSS  (layer ğ‘‘ âˆ’ 1)

(â„â€²  + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes
(â„â€²  + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes

(â„â€²  + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes

Figure 13. HT signature data format

the

14
In addition to the ğ‘›-byte message ğ‘€,
ht_sign function (Algorithm 12) takes as input
SK.seed and PK.seed from the SLH-DSA private key, the index of the XMSS tree at the lowest
layer that will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTS+  key within the XMSS tree
that will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“.
Algorithm 12 begins in lines 1 through 3 by signing ğ‘€ with the specified XMSS key using the
WOTS+ key within that XMSS key specified by ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“. The XMSS public key is obtained (line 5 or
14) for each successive layer and signed by the appropriate key at the next higher level (lines 7
through 11).

14In SLH-DSA, the message ğ‘€ that is provided to ht_sign is a FORS public key.

26

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 12 ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“)
Generates a hypertree signature.
Input: Message ğ‘€, private seed SK.seed, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’,

leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“.
Output: HT signature SIGğ»ğ‘‡.
1:  ADRS â† toByte(0, 32)
2:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
3:  SIGğ‘¡ğ‘šğ‘  â† xmss_sign(ğ‘€ , SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, PK.seed, ADRS)
4:  SIGğ»ğ‘‡  â† SIGğ‘¡ğ‘šğ‘
5:  ğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)
6:  for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:  end for
17:  return SIGğ»ğ‘‡

ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  mod 2â„â€²
ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â‰« â„â€²
ADRS.setLayerAddress(ğ‘—)
ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
SIGğ‘¡ğ‘šğ‘  â† xmss_sign(ğ‘Ÿğ‘œğ‘œğ‘¡, SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, PK.seed, ADRS)
SIGğ»ğ‘‡  â† SIGğ»ğ‘‡  âˆ¥ SIGğ‘¡ğ‘šğ‘
if ğ‘— < ğ‘‘ âˆ’ 1 then

end if

ğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, SIGğ‘¡ğ‘šğ‘, ğ‘Ÿğ‘œğ‘œğ‘¡, PK.seed, ADRS)

â–· â„â€²  least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’
â–· remove least significant â„â€²  bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’

27

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

7.2  Hypertree  Signature  Verification

Hypertree signature verification works by making ğ‘‘ calls to xmss_pkFromSig (Algorithm 11) and
comparing the result to the public key of the hypertree.

In addition to the ğ‘›-byte message ğ‘€ and the (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›-byte signature SIGğ»ğ‘‡, ht_verify
(Algorithm 13) takes as input PK.seed and PK.root from the SLH-DSA public key, the index of
the XMSS tree at the lowest layer that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTS+
key within the XMSS tree that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“.
At each layer, either the message ğ‘€ or the computed public key of the XMSS key at the lower
layer is provided along with the appropriate XMSS signature to xmss_pkFromSig in order to
obtain the layerâ€™s computed XMSS public key. If the computed XMSS public key of the top layer
tree is the same as the known hypertree public key, PK.root, then verification succeeds.

Algorithm 13 ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, PK.root)
Verifies a hypertree signature.
Input: Message ğ‘€, signature SIGğ»ğ‘‡, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“,

HT public key PK.root.

â–· SIGğ»ğ‘‡[0 âˆ¶ (â„â€²  + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]

Output: Boolean.
1:  ADRS â† toByte(0, 32)
2:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
3:  SIGğ‘¡ğ‘šğ‘  â† SIGğ»ğ‘‡.getXMSSSignature(0)
4:  ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)
5:  for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do
6:
7:
8:
9:
10:
11:
12:  end for
13:  if ğ‘›ğ‘œğ‘‘ğ‘’ = PK.root then
return true
14:
15:  else
16:
17:  end if

ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  mod 2â„â€²
ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â‰« â„â€²
ADRS.setLayerAddress(ğ‘—)
ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
SIGğ‘¡ğ‘šğ‘  â† SIGğ»ğ‘‡.getXMSSSignature(ğ‘—)  â–· SIGğ»ğ‘‡[ğ‘— â‹… (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› âˆ¶ (ğ‘— + 1)(â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]
ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, SIGğ‘¡ğ‘šğ‘, ğ‘›ğ‘œğ‘‘ğ‘’, PK.seed, ADRS)

â–· â„â€²  least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’
â–· remove least significant â„â€²  bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’

return false

28

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

8.  Forest  of  Random  Subsets  (FORS)

FORS is a few-time signature scheme that is used to sign the digests of the actual messages.
Unlike WOTS+ , for which forgeries become feasible if a key is used twice [22], the security of a
FORS key degrades gradually as the number of signatures increases.

FORS uses two parameters: ğ‘˜ and ğ‘¡ = 2ğ‘  (see Table 2). A FORS private key consists of ğ‘˜ sets of ğ‘¡
ğ‘›-byte strings, all of which are pseudorandomly generated from the seed SK.seed. Each of the
ğ‘˜ sets is formed into a Merkle tree, and the roots of the trees are hashed together to form the
FORS public key. A signature on a ğ‘˜ â‹… ğ‘-bit message digest consists of ğ‘˜ elements from the private
key, one from each set selected using ğ‘ bits of the message digest, along with the authentication
paths for each of these elements (see Figure 14).

private key value (tree 0)

ğ‘› bytes

AUTH (tree 0)

ğ‘ â‹… ğ‘› bytes

â‹¯
private key value (tree ğ‘˜ âˆ’ 1)

ğ‘› bytes

AUTH (tree ğ‘˜ âˆ’ 1)

ğ‘ â‹… ğ‘› bytes

Figure 14. FORS signature data format

8.1  Generating  FORS  Secret  Values

The fors_skGen function (Algorithm 14) generates the ğ‘›-byte strings of the FORS private key. The
function takes SK.seed and PK.seed from the SLH-DSA private key, an address, and an index
as input. The ğ‘¡ğ‘¦ğ‘ğ‘’ in the address ADRS must be set to FORS_TREE, and the tree address and
key pair address must be set to the index of the WOTS+  key within the XMSS tree that signs the
FORS key. The layer address must be set to zero. The index ğ‘–ğ‘‘ğ‘¥ is the index of the FORS secret
value within the sets of FORS trees.

Algorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)
Generates a FORS private-key value.
Input: Secret seed SK.seed, public seed PK.seed, address ADRS, secret key index ğ‘–ğ‘‘ğ‘¥.
Output: ğ‘›-byte FORS private-key value.

1:  skADRS â† ADRS
2:  skADRS.setTypeAndClear(FORS_PRF)
3:  skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
4:  skADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)
5:  return PRF(PK.seed, SK.seed, skADRS)

â–· copy address to create key generation address

29

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

8.2  Generating  a  Merkle  Hash  Tree

The fors_node function (Algorithm 15) computes the nodes of a Merkle tree. It is the same as
xmss_node, except that the leaf nodes are the hashes of the FORS secret values instead of WOTS+
public keys.

The fors_node function takes as input SK.seed and PK.seed from the SLH-DSA private key; a
target node index ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which
is the height within the Merkle tree of the node being computed; and an address. The address
ADRS must have the layer address set to zero (since the XMSS tree that signs a FORS key is
always at layer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to
FORS_TREE, and the key pair address set to the index of the WOTS+  key within the XMSS tree
that signs the FORS key. The target node height and index must satisfy ğ‘§ â‰¤ ğ‘ and ğ‘– < ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘§).

Each node in the Merkle tree is the root of a subtree, and Algorithm 15 computes the root of a
subtree recursively. If the subtree consists of a single leaf node, then the function simply returns
a hash of the nodeâ€™s private ğ‘›-byte string (lines 2 through 5). Otherwise, the function computes
the roots of the left subtree (line 7) and right subtree (line 8) and hashes them together (lines 9
through 11).

Algorithm 15 fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)
Computes the root of a Merkle subtree of FORS public values.
Input: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,

address ADRS.

Output: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.

ğ‘ ğ‘˜ â† fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–)
ADRS.setTreeHeight(0)
ADRS.setTreeIndex(ğ‘–)
ğ‘›ğ‘œğ‘‘ğ‘’ â† F(PK.seed, ADRS, ğ‘ ğ‘˜)

ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)
ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)
ADRS.setTreeHeight(ğ‘§)
ADRS.setTreeIndex(ğ‘–)
ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)

1:  if ğ‘§ = 0 then
2:
3:
4:
5:
6:  else
7:
8:
9:
10:
11:
12:  end if
13:  return ğ‘›ğ‘œğ‘‘ğ‘’

8.3  Generating  a  FORS  Signature
The fors_sign function (Algorithm 16) signs a ğ‘˜ â‹… ğ‘-bit message digest ğ‘šğ‘‘.15
In addition to the
message digest, fors_sign takes SK.seed and PK.seed from the SLH-DSA private key and an
address as input. The address ADRS must have the layer address set to zero (since the XMSS

15For convenience, fors_sign takes a âŒˆ ğ‘˜â‹…ğ‘

8 âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits to sign.

30

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

tree that signs a FORS key is always at layer 0), the tree address set to the XMSS tree that signs
the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE, and the key pair address set to the index of the WOTS+
key within the XMSS tree that signs the FORS key.

The fors_sign function splits ğ‘˜â‹…ğ‘ bits of ğ‘šğ‘‘ into ğ‘˜ ğ‘-bit strings (line 2), each of which is interpreted
as an integer between 0 and ğ‘¡ âˆ’ 1. Each of these integers is used to select a secret value from
one of the ğ‘˜ sets (line 4). For each secret value selected, an authentication path is computed
and added to the signature (lines 5 through 9).

Algorithm 16 fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)
Generates a FORS signature.
Input: Message digest ğ‘šğ‘‘, secret seed SK.seed, address ADRS, public seed PK.seed.
Output: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘†.
1:  SIGğ¹ ğ‘‚ğ‘…ğ‘†  = NULL
2:  ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2b(ğ‘šğ‘‘, ğ‘, ğ‘˜)
3:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do
4:

â–· compute signature elements
SIGğ¹ ğ‘‚ğ‘…ğ‘†  â† SIGğ¹ ğ‘‚ğ‘…ğ‘†  âˆ¥ fors_skGen(SK.seed, PK.seed, ADRS, ğ‘– â‹… 2ğ‘  + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])
for ğ‘— from 0 to ğ‘ âˆ’ 1 do
â–· compute auth path

â–· initialize SIGğ¹ ğ‘‚ğ‘…ğ‘†  as a zero-length byte string

ğ‘  â† âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ âŠ• 1
AUTH[ğ‘—] â† fors_node(SK.seed, ğ‘– â‹… 2ğ‘âˆ’ğ‘—  + ğ‘ , ğ‘—, PK.seed, ADRS)

5:
6:
7:
8:
9:
10:  end for
11:  return SIGğ¹ ğ‘‚ğ‘…ğ‘†

end for
SIGğ¹ ğ‘‚ğ‘…ğ‘†  â† SIGğ¹ ğ‘‚ğ‘…ğ‘†  âˆ¥ AUTH

8.4  Computing  a  FORS  Public  Key  From  a  Signature

Verifying a FORS signature involves computing a public-key value from a message digest and
a signature value.  Verification succeeds if the correct public-key value is computed, which is
determined by verifying the hypertree signature on the computed public-key value using the SLH-
DSA public key. This section describes fors_pkFromSig (Algorithm 17), a function that computes
a candidate FORS public key from a FORS signature and corresponding message digest.

In addition to a message digest ğ‘šğ‘‘ and a ğ‘˜ â‹… (ğ‘ + 1) â‹… ğ‘›-byte signature SIGğ¹ ğ‘‚ğ‘…ğ‘†, fors_pkFromSig
takes PK.seed from the SLH-DSA public key and an address as input.16
The address ADRS
must have the layer address set to zero (since the XMSS tree that signs a FORS key is always at
layer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE,
and the key pair address set to the index of the WOTS+  key within the XMSS tree that signs the
FORS key.

The fors_pkFromSig function begins by computing the roots of each of the ğ‘˜ Merkle trees (lines
2 through 20). As in fors_sign, ğ‘˜ â‹… ğ‘ bits of the message digest are split into ğ‘˜ ğ‘-bit strings (line
1), each of which is interpreted as an integer between 0 and ğ‘¡ âˆ’ 1.  The integers are used to
determine the locations in the Merkle trees of the secret values from the signature (lines 3

16As with fors_sign, fors_pkFromSig takes a âŒˆ ğ‘˜â‹…ğ‘

8 âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits.

31

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

through 5). The hashes of the secret values are computed (line 6), and the hash values are used
along with the corresponding authentication paths from the signature to compute the Merkle
tree roots (lines 7 through 19). Once all of the Merkle tree roots have been computed, they are
hashed together to compute the FORS public key (lines 21 through 24).

Algorithm 17 fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘†, ğ‘šğ‘‘, PK.seed, ADRS)
Computes a FORS public key from a FORS signature.
Input: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘†, message digest ğ‘šğ‘‘, public seed PK.seed, address ADRS.
Output: FORS public key.
1:  ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2b(ğ‘šğ‘‘, ğ‘, ğ‘˜)
2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do
3:
4:
5:
6:

ğ‘ ğ‘˜ â† SIGğ¹ ğ‘‚ğ‘…ğ‘†.getSK(ğ‘–)
ADRS.setTreeHeight(0)
ADRS.setTreeIndex(ğ‘– â‹… 2ğ‘  + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])
ğ‘›ğ‘œğ‘‘ğ‘’[0] â† F(PK.seed, ADRS, ğ‘ ğ‘˜)

â–· SIGğ¹ ğ‘‚ğ‘…ğ‘†[ğ‘– â‹… (ğ‘ + 1) â‹… ğ‘› âˆ¶ (ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘›]
â–· compute leaf

ğ‘ğ‘¢ğ‘¡â„ â† SIGğ¹ ğ‘‚ğ‘…ğ‘†.getAUTH(ğ‘–)  â–· SIGğ¹ ğ‘‚ğ‘…ğ‘†[(ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘› âˆ¶ (ğ‘– + 1) â‹… (ğ‘ + 1) â‹… ğ‘›]
for ğ‘— from 0 to ğ‘ âˆ’ 1 do
â–· compute root from leaf and AUTH

else

ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)
ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘ğ‘¢ğ‘¡â„[ğ‘—] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])

ADRS.setTreeIndex(ADRS.getTreeIndex()/2)
ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ ğ‘ğ‘¢ğ‘¡â„[ğ‘—])

ADRS.setTreeHeight(ğ‘— + 1)
if âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ is even then

7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:  end for
21:  forspkADRS â† ADRS
22:  forspkADRS.setTypeAndClear(FORS_ROOTS)
23:  forspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())
24:  ğ‘ğ‘˜ â† Tğ‘˜(PK.seed, forspkADRS, ğ‘Ÿğ‘œğ‘œğ‘¡)
25:  return ğ‘ğ‘˜

end if
ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]

end for
ğ‘Ÿğ‘œğ‘œğ‘¡[ğ‘–] â† ğ‘›ğ‘œğ‘‘ğ‘’[0]

â–· copy address to create a FORS public-key address

â–· compute the FORS public key

32

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

9.  SLH-DSA  Internal  Functions

SLH-DSA uses the hypertree and the FORS keys to create a stateless hash-based signature scheme.
The SLH-DSA private key contains a secret seed value and a secret PRF key. The public key consists
of a key identifier PK.seed and the root of the hypertree.  A signature is created by hashing
the message, using part of the message digest to select a FORS key, signing other bits from the
message digest with the FORS key, and generating a hypertree signature for the FORS key. The
parameters for SLH-DSA are those specified previously for WOTS+ , XMSS, the SLH-DSA hypertree,
and FORS (see Table 2).

SLH-DSA uses one additional parameter ğ‘š, which is the length in bytes of the message digest. It
is computed as:

ğ‘š = âŒˆ

â„ âˆ’ â„â€²
8

âŒ‰ + âŒˆ

â„â€²
8

âŒ‰ + âŒˆ

ğ‘˜ â‹… ğ‘
8

âŒ‰

SLH-DSA uses â„ bits of the message digest to select a FORS key: â„ âˆ’ â„â€²  bits to select an XMSS
tree at the lowest layer and â„â€² bits to select a WOTS+ key and corresponding FORS key from that
tree. ğ‘˜ â‹… ğ‘ bits of the digest are signed by the selected FORS key. While only â„ + ğ‘˜ â‹… ğ‘ bits of the
message digest are used, implementation is simplified by extracting the necessary bits from a
slightly larger digest.

This section describes the functions for SLH-DSA key generation, signature generation, and
signature verification. In the functions in this section, where randomness is required, the random
values are provided as inputs to the functions. The interfaces specified in this section will be used
when testing of SLH-DSA implementations is performed through the Cryptographic Algorithm
Validation Program (CAVP). The key generation function in this section may also be used to obtain
the assurance of private key possession via regeneration, as described in Section 3.1.

Other than for testing purposes, the interfaces for key generation and signature generation
specified in this section should not be made available to applications, as any random values
required for key generation and signature generation shall be generated by the cryptographic
module. Section 10 provides guidance on the interfaces to be made available to applications.

9.1  SLH-DSA  Key  Generation

SLH-DSA public keys contain two elements (see Figure 16).  The first is an ğ‘›-byte public seed
PK.seed, which is used in many hash function calls to provide domain separation between
different SLH-DSA key pairs. The second value is the hypertree public key (i.e., the root of the
top layer XMSS tree). PK.seed shall be generated using an approved random bit generator (see

SK.seed
SK.prf
PK.seed
PK.root

ğ‘› bytes
ğ‘› bytes
ğ‘› bytes
ğ‘› bytes

PK.seed
PK.root

ğ‘› bytes
ğ‘› bytes

Figure 15. SLH-DSA private key

Figure 16. SLH-DSA public key

33

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

[14, 15, 16]), where the instantiation of the random bit generator supports at least 8ğ‘› bits of
security strength.

The SLH-DSA private key contains two random, secret ğ‘›-byte values (see Figure 15). SK.seed is
used to generate all of the WOTS+  and FORS private key elements. SK.prf is used to generate a
randomization value for the randomized hashing of the message in SLH-DSA. The private key
also includes a copy of the public key. Both SK.seed and SK.prf shall be generated using an
approved random bit generator, where the instantiation of the random bit generator supports
at least 8ğ‘› bits of security strength.

Algorithm 18 generates an SLH-DSA key pair. Lines 1 through 3 compute the root of the top layer
XMSS tree.  Line 4 bundles the three inputs and the computed PK.seed into the private and
public keys.

SLH-DSA signing has two variants â€” â€œhedgedâ€ and deterministic (see Section 9.2) â€” whose keys
should only be used for the generation and verification of hedged and deterministic SLH-DSA
digital signatures, respectively.

Algorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed)
Generates an SLH-DSA key pair.
Input: Secret seed SK.seed, PRF key SK.prf, public seed PK.seed
Output: SLH-DSA key pair (SK, PK).
1:  ADRS â† toByte(0, 32)
2:  ADRS.setLayerAddress(ğ‘‘ âˆ’ 1)
3:  PK.root â† xmss_node(SK.seed, 0, â„â€², PK.seed, ADRS)
4:  return ( (SK.seed, SK.prf, PK.seed, PK.root), (PK.seed, PK.root) )

â–· generate the public key for the top-level XMSS tree

9.2  SLH-DSA  Signature  Generation

An SLH-DSA signature consists of a randomization string, a FORS signature, and a hypertree
signature, as shown in Figure 17.

Generating an SLH-DSA signature (Algorithm 19) begins by creating an ğ‘š-byte message digest
(lines 2 through 5). A PRF is used to create a message randomizer (line 3), and it is hashed along
with the message to create the digest (line 5). Bits are then extracted from the message digest to
be signed by the FORS key (line 6), to select an XMSS tree (lines 7 and 9), and to select a WOTS+
key and corresponding FORS key within that XMSS tree (lines 8 and 10). Next, the FORS signature
is computed (lines 11 through 14), and the corresponding FORS public key is obtained (line 16).
Finally, the FORS public key is signed (line 17).

Randomness R
FORS signature SIGFORS
HT signature SIGHT

ğ‘› bytes
ğ‘˜(1 + ğ‘) â‹… ğ‘› bytes
(â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes

Figure 17. SLH-DSA signature data format

34

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 19 slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)
Generates an SLH-DSA signature.
Input: Message ğ‘€, private key SK = (SK.seed, SK.prf, PK.seed, PK.root),

(optional) additional randomness ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘.

Output: SLH-DSA signature SIG.
1:  ADRS â† toByte(0, 32)

2:  ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘  â–· substitute ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† PK.seed for the deterministic variant
3:  ğ‘… â† PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ )
â–· generate randomizer
4:  SIG â† ğ‘…

â–· compute message digest
â–· first âŒˆ ğ‘˜â‹…ğ‘
8  âŒ‰ bytes
â–· next âŒˆ â„âˆ’â„/ğ‘‘
8  âŒ‰ bytes
â„ âŒ‰ bytes
â„ âŒ‰]  â–· next âŒˆ 8ğ‘‘

8  âŒ‰]
8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘

8  âŒ‰ + âŒˆ 8ğ‘‘

8 âŒ‰]

5:  ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )
6:  ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆ ğ‘˜â‹…ğ‘
7:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘
8:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘

8  âŒ‰ âˆ¶ âŒˆ ğ‘˜â‹…ğ‘
8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘
ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘

8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘
8  âŒ‰ âˆ¶ âŒˆ ğ‘˜â‹…ğ‘

8

âŒ‰) mod 2â„âˆ’â„/ğ‘‘

8ğ‘‘âŒ‰) mod 2â„/ğ‘‘

9:
10:  ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, âŒˆ â„
11:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
12:  ADRS.setTypeAndClear(FORS_TREE)
13:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“)
14:  SIGğ¹ ğ‘‚ğ‘…ğ‘†  â† fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)
15:  SIG â† SIG âˆ¥ SIGğ¹ ğ‘‚ğ‘…ğ‘†
16:  PKğ¹ ğ‘‚ğ‘…ğ‘†  â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘†, ğ‘šğ‘‘, PK.seed, ADRS)
17:  SIGğ»ğ‘‡  â† ht_sign(PKğ¹ ğ‘‚ğ‘…ğ‘†, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“)
18:  SIG â† SIG âˆ¥ SIGğ»ğ‘‡
19:  return SIG

â–· get FORS key

35

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

The message randomizer may be set in either a non-deterministic or deterministic way, depending
on whether ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an input. For the â€œhedgedâ€ variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an
input, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘. The hedged variant is the default and should be used on
platforms where side-channel attacks are a concern. When using the hedged version, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘
shall be an ğ‘›-byte random value. While ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ should ideally be generated by an approved
random bit generator, other methods for generating fresh random values may be used.  For
the deterministic variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is not provided as an input, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to PK.seed,
which results in signing being deterministic (i.e., signing the same message twice will result in
the same signature).  The deterministic variant is available for platforms where a random bit
generator is not available.

9.3  SLH-DSA  Signature  Verification

As with signature generation, SLH-DSA signature verification (Algorithm 20) begins by computing
a message digest (line 8) and then extracting ğ‘šğ‘‘ (line 9), ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  (lines 10 and 12), and ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“
(lines 11 and 13) from the digest. A candidate FORS public key is then computed (line 17), and
the signature on the FORS key is verified (line 18). If this signature verification succeeds, then
the correct FORS public key was computed, and the signature SIG on message ğ‘€ is valid.

Algorithm 20 slh_verify_internal(ğ‘€, SIG, PK)
Verifies an SLH-DSA signature.
Input: Message ğ‘€, signature SIG, public key PK = (PK.seed, PK.root).
Output: Boolean.

8 âŒ‰]

return false

1:  if |SIG| â‰  (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› then
2:
3:  end if
4:  ADRS â† toByte(0, 32)
5:  ğ‘… â† SIG.getR()
â–· SIG[0 âˆ¶ ğ‘›]
â–· SIG[ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘›]
6:  SIGğ¹ ğ‘‚ğ‘…ğ‘†  â† SIG.getSIG_FORS()
7:  SIGğ»ğ‘‡  â† SIG.getSIG_HT()  â–· SIG[(1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]
â–· compute message digest
8:  ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )
â–· first âŒˆ ğ‘˜â‹…ğ‘
9:  ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆ ğ‘˜â‹…ğ‘
8  âŒ‰ bytes
â–· next âŒˆ â„âˆ’â„/ğ‘‘
10:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘
8  âŒ‰ âˆ¶ âŒˆ ğ‘˜â‹…ğ‘
8  âŒ‰ bytes
8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘
â„ âŒ‰ bytes
â„ âŒ‰]  â–· next âŒˆ 8ğ‘‘
11:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘
12:  ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’  â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘
13:  ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“  â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, âŒˆ â„
14:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)
15:  ADRS.setTypeAndClear(FORS_TREE)
16:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“)
17:  PKğ¹ ğ‘‚ğ‘…ğ‘†  â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘†, ğ‘šğ‘‘, PK.seed, ADRS)
18:  return ht_verify(PKğ¹ ğ‘‚ğ‘…ğ‘†, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“, PK.root)

8  âŒ‰]
8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘

8  âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘
8  âŒ‰ âˆ¶ âŒˆ ğ‘˜â‹…ğ‘

â–· compute FORS public key

8ğ‘‘âŒ‰) mod 2â„/ğ‘‘

âŒ‰) mod 2â„âˆ’â„/ğ‘‘

8  âŒ‰ + âŒˆ 8ğ‘‘

8

36

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

10.  SLH-DSA  External  Functions

This section provides guidance on the key generation,  signature generation,  and signature
verification functions that should be provided for use by applications.  The functions in this
section use the functions in Section 9 to implement the underlying SLH-DSA scheme.

10.1  SLH-DSA  Key  Generation

Algorithm 21 generates an SLH-DSA key pair.  Lines 1 through 3 generate the random values
for the private and public keys, and line 7 calls slh_keygen_internal to compute PK.root and
return the private and public key. PK.seed, SK.seed, and SK.prf shall be generated using an
approved random bit generator (see  [14, 15, 16]), where the instantiation of the random bit
generator supports at least 8ğ‘› bits of security strength.

Algorithm 21 slh_keygen()
Generates an SLH-DSA key pair.
Input: (none)
Output: SLH-DSA key pair (SK, PK).
1:  SK.seed â†âˆ’ ğ”¹ğ‘›
2:  SK.prf â†âˆ’ ğ”¹ğ‘›
3:  PK.seed â†âˆ’ ğ”¹ğ‘›

$

$

$

â–· set SK.seed, SK.prf, and PK.seed to random ğ‘›-byte
â–· strings using an approved random bit generator

4:  if SK.seed = NULL or SK.prf = NULL or PK.seed = NULL then
5:
6:  end if

return âŠ¥

â–· return an error indication if random bit generation failed

7:  return slh_keygen_internal(SK.seed, SK.prf, PK.seed)

10.2  SLH-DSA  Signature  Generation

This section presents two versions of SLH-DSA signature generation: a â€œpureâ€ version (slh_sign)
and a â€œpre-hashâ€ version (hash_slh_sign).  Both versions use slh_sign_internal, but they differ
in how the message input to slh_sign_internal is created from the content to be signed. In the
pure version, the content is signed by slh_sign_internal along with some domain separation
information. In the pre-hash version, a hash of the content is signed by slh_sign_internal along
with some domain separation information.

Both versions take the content to be signed, the private key, and a context as input. The pre-hash
version also takes as input a hash function or XOF that is to be used to pre-hash the content to
be signed. The context string has a maximum length of 255 bytes. By default, the context is the
empty string. However, applications may specify the use of a non-empty context string.

The identifier for a signature (e.g., the object identifier [OID]) should indicate whether the
signature is a pure signature or a pre-hash signature.  In the case of pre-hash signatures, the
identifier should also indicate the hash function or XOF used to compute the pre-hash.17
While

17In the case of a XOF, this would also include the length of the output from the XOF.

37

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

a single key pair may be used for both pure and pre-hash signatures, it is recommended that
each key pair only be used for one version or the other. If a non-empty context string is to be
used, this should either be indicated by the signatureâ€™s identifier or the application with which
the signature is being used.

If the default hedged variant of slh_sign_internal is used, the ğ‘›-byte random value ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘
shall be generated by the cryptographic module that runs slh_sign_internal.  However, ğ‘€ â€²  in
Algorithms 22 and 23 may be constructed outside of the crytographic module. In the case of
hash_slh_sign, the hash or XOF of the content to be signed must be computed within a FIPS
140-validated cryptographic module, but it may be a different cryptographic module than the
one that runs slh_sign_internal.

In general, the pure version is preferred. However, for some cryptographic modules that generate
SLH-DSA signatures, performing lines 3 and 5 of Algorithm 19 may be infeasible if the message ğ‘€
is large. This may, for example, be the result of the module having limited memory to store the
message to be signed. Similarly, for some cryptographic modules that verify SLH-DSA signatures,
performing line 8 of Algorithm 20 may be infeasible if the message ğ‘€ is large.  For some use
cases, these issues may be addressed by signing a digest of the content rather than signing the
content directly.

In many cases where the content to be signed is large, hashing of the content is performed at
the application level.  For example, in the Cryptographic Message Syntax [23], a digest of the
content may be computed, and that digest is signed along with other attributes.  In cases in
which the content is not hashed at the application level, the pre-hash version of SLH-DSA signing
(Section 10.2.2) may be used.

To maintain the same level of security strength when the content is hashed at the application
level or when using the pre-hash version of SLH-DSA, the digest that is signed needs to be
generated using an approved hash function or XOF (e.g., from FIPS 180-4 [8] or FIPS 202 [6]) that
provides at least 8ğ‘› bits of classical security strength against both collision and second preimage
attacks [6, Table 4].18
Verification of a signature created in this way will require the verify function
to generate a digest from the message in the same way for input to the verification function.

Even if it is feasible to compute collisions on the hash functions or XOF used to instantiate Hğ‘šğ‘ ğ‘”,
PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tğ‘™, there is believed to be no adverse effect on the security of
SLH-DSA.19
However, if the input to the signing function is a digest of the content, then collisions
on the function used to compute the digest can result in forged messages.

10.2.1  Pure  SLH-DSA  Signature  Generation

In the pure version, the content to be signed is prepended with a one-byte domain separator,
one byte that indicates the length of the context string, and the context string.  The domain
separator, which has a value of zero for pure signing, is included to prevent pre-hash signatures
from verifying as pure signatures and vice versa. In the default case in which the context string

18Obtaining at least 8ğ‘› bits of classical security strength against collision attacks requires that the digest to be

signed is at least 2ğ‘› bytes in length.

19As noted in Section 11, applications that require message-bound signatures may be adversely affected if it is

feasible to compute collisions on Hğ‘šğ‘ ğ‘”.

38

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

is empty, pure signing simply involves prepending two zero bytes to the content to be signed
and passing the result to slh_sign_internal along with the private key and, in the case of hedged
signing, an ğ‘›-byte random value.

Algorithm 22 slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)
Generates a pure SLH-DSA signature.
Input: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, private key SK.
Output: SLH-DSA signature SIG.

if |ğ‘ğ‘¡ğ‘¥| > 255 then

return âŠ¥

$

ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ â†âˆ’ ğ”¹ğ‘›
if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then

return âŠ¥

1:
2:
3:  end if

4:
5:
6:
7:  end if

â–· return an error indication if the context string is too long

â–· skip lines 4 through 7 for the deterministic variant

â–· return an error indication if random bit generation failed

ğ‘€ â€²  â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€
SIG â† slh_sign_internal(ğ‘€ â€² , SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)  â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant

8:
9:
10:  return SIG

10.2.2  HashSLH-DSA  Signature  Generation

In the pre-hash version, the message input to slh_sign_internal is the result of applying either a
hash function or a XOF to the content to be signed. The output of the hash function or XOF is
prepended by a one-byte domain separator, one byte that indicates the length of the context
string, the context string, and the distinguished encoding rules (DER) encoding of the hash
function or XOFâ€™s OID. The domain separator has a value of one for pre-hash signing. The DER
encoding of the OID includes the tag and length.

Algorithm 23 shows the DER encodings of the OIDs for SHA-256, SHA-512, SHAKE128, and
SHAKE256. However, hash_slh_sign may be used with other hash functions or XOFs. SHA-256
and SHAKE128 are only appropriate for use with SLH-DSA parameter sets that are claimed to be
in security category 1 (see Section 11).

39

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 23 hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)
Generates a pre-hash SLH-DSA signature.
Input: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, private key SK.
Output: SLH-DSA signature SIG.

1:  if |ğ‘ğ‘¡ğ‘¥| > 255 then
return âŠ¥
2:
3:  end if
4:  ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ â†âˆ’ ğ”¹ğ‘›
5:  if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then
6:
7:  end if

return âŠ¥

$

â–· return an error indication if the context string is too long

â–· skip lines 4 through 7 for the deterministic variant

â–· return an error indication if random bit generation failed

case SHA-256:

8:  switch PH do
9:
10:
11:

OID â† toByte(0x0609608648016503040201, 11)
PHğ‘€  â† SHA-256(ğ‘€ )

â–· 2.16.840.1.101.3.4.2.1

12:
13:
14:

15:
16:
17:

18:
19:
20:

case SHA-512:

OID â† toByte(0x0609608648016503040203, 11)
PHğ‘€  â† SHA-512(ğ‘€ )

â–· 2.16.840.1.101.3.4.2.3

case SHAKE128:

OID â† toByte(0x060960864801650304020B, 11)
PHğ‘€  â† SHAKE128(ğ‘€ , 256)

â–· 2.16.840.1.101.3.4.2.11

case SHAKE256:

OID â† toByte(0x060960864801650304020C, 11)
PHğ‘€  â† SHAKE256(ğ‘€ , 512)

â–· 2.16.840.1.101.3.4.2.12

case â€¦
â€¦

21:
22:
23:  end switch
24:  ğ‘€ â€²  â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€
25:  SIG â† slh_sign_internal(ğ‘€ â€², SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)  â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant
26:  return SIG

â–· other approved hash functions or XOFs

40

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

10.3  SLH-DSA  Signature  Verification

Algorithms 24 and 25 present the pure and pre-hash versions of SLH-DSA signature verification
that correspond to the pure and pre-hash versions of SLH-DSA signature generation in Sec-
tion 10.2. These functions construct ğ‘€ â€²  in the same way as Algorithms 22 and 23, respectively,
and pass the resulting ğ‘€ â€²  to slh_verify_internal for verification. As with signature generation,
ğ‘€ â€²  may be constructed outside of the cryptographic module that performs slh_verify_internal.
However, in the case of hash_slh_verify, the hash or XOF of the content must be computed within
a FIPS 140-validated cryptographic module, which may be a different cryptographic module than
the one that performs slh_verify_internal.

The identifier associated with the signature should indicate whether the pure or pre-hash version
of signature verification should be used, and in the pre-hash case, the hash function or XOF to
use to compute the pre-hash. A non-empty context string should be used in verification if one is
specified in the signatureâ€™s identifier or by the application with which the signature is being used.

Algorithm 24 slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK)
Verifies a pure SLH-DSA signature.
Input: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, public key PK.
Output: Boolean.

return false

1:  if |ğ‘ğ‘¡ğ‘¥| > 255 then
2:
3:  end if
4:  ğ‘€ â€²  â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€
5:  return slh_verify_internal(ğ‘€ â€², SIG, PK)

41

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Algorithm 25 hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)
Verifies a pre-hash SLH-DSA signature.
Input: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, public key PK.
Output: Boolean.

1:  if |ğ‘ğ‘¡ğ‘¥| > 255 then
2:
3:  end if

return false

case SHA-256:

4:  switch PH do
5:
6:
7:

OID â† toByte(0x0609608648016503040201, 11)
PHğ‘€  â† SHA-256(ğ‘€ )

â–· 2.16.840.1.101.3.4.2.1

8:
9:
10:

11:
12:
13:

14:
15:
16:

case SHA-512:

OID â† toByte(0x0609608648016503040203, 11)
PHğ‘€  â† SHA-512(ğ‘€ )

â–· 2.16.840.1.101.3.4.2.3

case SHAKE128:

OID â† toByte(0x060960864801650304020B, 11)
PHğ‘€  â† SHAKE128(ğ‘€ , 256)

â–· 2.16.840.1.101.3.4.2.11

case SHAKE256:

OID â† toByte(0x060960864801650304020C, 11)
PHğ‘€  â† SHAKE256(ğ‘€ , 512)

â–· 2.16.840.1.101.3.4.2.12

case â€¦
â€¦

17:
18:
19:  end switch
20:  ğ‘€ â€²  â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€
21:  return slh_verify_internal(ğ‘€ â€², SIG, PK)

â–· other approved hash functions or XOFs

42

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

11.  Parameter  Sets

This standard approves 12 parameter sets for use with SLH-DSA. A parameter set consists of
parameters for WOTS+  (ğ‘› and ğ‘™ğ‘”ğ‘¤), XMSS and the SLH-DSA hypertree (â„ and ğ‘‘), and FORS (ğ‘˜
and ğ‘), as well as instantiations for the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“.
Table 2 lists the parameter sets that are approved for use.20
Each parameter set name indicates
the hash function family (SHA2 or SHAKE) that is used to instantiate the hash functions, the
length in bits of the security parameter ğ‘›, and whether the parameter set was designed to create
relatively small signatures (â€˜sâ€™) or to have relatively fast signature generation (â€˜fâ€™). There are six
sets of values for ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘ that are approved for use.  For each of the six sets of
values, the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“  may be instantiated using either
SHAKE [6] or SHA-2 [8].  For the SHAKE parameter sets, the functions shall be instantiated as
specified in Section 11.1. For the SHA2 parameter sets, the functions shall be instantiated as
specified in Section 11.2.1 if ğ‘› = 16 and shall be instantiated as specified in Section 11.2.2 if
ğ‘› = 24 or ğ‘› = 32.

21

Table 2. SLH-DSA parameter sets

ğ‘›

â„

ğ‘‘  â„â€²

ğ‘

ğ‘˜

ğ‘™ğ‘”ğ‘¤  ğ‘š

16  63

7  9  12  14

16  66  22  3

6  33

24  63

7  9  14  17

24  66  22  3

8  33

32  64

8  8  14  22

32  68  17  4

9  35

4

4

4

4

4

4

30

34

39

42

47

49

security
category

pk
bytes

sig
bytes

1

1

3

3

5

5

32

7 856

32

17 088

48

16 224

48

35 664

64

29 792

64

49 856

SLH-DSA-SHA2-128s
SLH-DSA-SHAKE-128s
SLH-DSA-SHA2-128f
SLH-DSA-SHAKE-128f
SLH-DSA-SHA2-192s
SLH-DSA-SHAKE-192s
SLH-DSA-SHA2-192f
SLH-DSA-SHAKE-192f
SLH-DSA-SHA2-256s
SLH-DSA-SHAKE-256s
SLH-DSA-SHA2-256f
SLH-DSA-SHAKE-256f

The 12 parameter sets included in Table 2 were designed to meet certain security strength
categories defined by NIST in its original Call for Proposals [25] with respect to existential un-
forgeability under chosen message attack (EUF-CMA) when each key pair is used to sign at most
264
These security strength categories are explained further in SP 800-57, Part 1 [9].

messages. 22

20SP 800-230 [24] specifies additional parameter sets that are approved for use. While key pairs generated for the
parameter sets specified in this standard may be used to sign up to 264  messages, key pairs generated for the
parameter sets in SP 800-230 are more limited in the number of signatures that may be generated.

21In addition to ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘, Table 2 also lists values for parameters that may be computed from these
values (â„â€² , ğ‘š, public-key size(pk bytes), and signature size(sig bytes)).  The security category is the security
category in which the parameter set is claimed to be [10].

22If a key pair were used to sign 10 billion (1010) messages per second, it would take over 58 years to sign 264

messages.

43

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Using this approach, security strength is not described by a single number, such as â€œ128 bits of
security.â€ Instead, each parameter set is claimed to be at least as secure as a generic block cipher
with a prescribed key size. More precisely, it is claimed that the computational resources needed
to break SLH-DSA are greater than or equal to the computational resources needed to break the
block cipher when these computational resources are estimated using any realistic model of
computation. Different models of computation can be more or less realistic and, accordingly,
lead to more or less accurate estimates of security strength. Some commonly studied models
are discussed in [26].

Concretely,  the parameter sets with ğ‘›  =  16 are claimed to be in security category 1,  the
parameter sets with ğ‘› = 24 are claimed to be in security category 3, and the parameter sets with
ğ‘› = 32 are claimed to be in security category 5 [10]. For additional discussion of the security
strength of SLH-DSA, see [10, 27].

Some applications require a property known as message-bound signatures [28, 29],  which
intuitively requires that it be infeasible for anyone to create a public key and a signature that
are valid for two different messages. Signature schemes are not required to have this property
under the EUF-CMA security definition used in assigning security categories.  In the case of
SLH-DSA, the key pair owner could create two messages with the same signature by finding
a collision on Hğ‘šğ‘ ğ‘”.  Due to the length of the output of Hğ‘šğ‘ ğ‘”, finding such a collision would
be expected to require fewer computational resources than specified for the parameter setsâ€™
claimed security categories in all cases except SLH-DSA-SHA2-128f and SLH-DSA-SHAKE-128f.23
Therefore, applications that require message-bound signatures should either take the expected
cost of finding collisions on Hğ‘šğ‘ ğ‘”  into account when choosing an appropriate parameter set or
apply a technique (e.g., the BUFF transformation [29]) to obtain the message-bound signatures
property.

11.1  SLH-DSA  Using  SHAKE

Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“  shall be instantiated as follows for the SLH-DSA-SHAKE-
128s, SLH-DSA-SHAKE-128f, SLH-DSA-SHAKE-192s, SLH-DSA-SHAKE-192f, SLH-DSA-SHAKE-256s,
and SLH-DSA-SHAKE-256f parameter sets:

Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) = SHAKE256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ , 8ğ‘š)
PRF(PK.seed, SK.seed, ADRS) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ SK.seed, 8ğ‘›)
PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) = SHAKE256(SK.prf âˆ¥ ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ , 8ğ‘›)
F(PK.seed, ADRS, ğ‘€1) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€1, 8ğ‘›)
H(PK.seed, ADRS, ğ‘€2) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€2, 8ğ‘›)
Tâ„“(PK.seed, ADRS, ğ‘€â„“) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â„“, 8ğ‘›)

11.2  SLH-DSA  Using  SHA2

In Sections 11.2.1 and 11.2.2, the functions MGF1-SHA-256 and MGF1-SHA-512 are MGF1 from
Appendix B.2.1 of RFC 8017 [30], where Hash is SHA-256 or SHA-512, respectively. The functions

23Finding a collision would be expected to require computing Hğ‘šğ‘ ğ‘”  for approximately 2(â„+ğ‘˜â‹…ğ‘)/2  different mes-

sages.

44

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

HMAC-SHA-256 and HMAC-SHA-512 are the HMAC function from FIPS 198-1 [31, 32], where ğ»
is SHA-256 or SHA-512, respectively.

The functions in Sections 11.2.1 and 11.2.2 make use of a compressed version of ADRS (see
Figure 18). A compressed address (ADRS  ) is a 22-byte string that is the same as an ADRS
with the exceptions that the encodings of the layer address and type are reduced to one byte
each and the encoding of the tree address is reduced to eight bytes (i.e., ADRSğ‘  = ADRS[3] âˆ¥
ADRS[8 âˆ¶ 16] âˆ¥ ADRS[19] âˆ¥ ADRS[20 âˆ¶ 32]). For implementations of the SHA2 parameter
sets that store addresses in compressed form (i.e., 22 bytes), the member functions (Section 4.3)
are as shown in Table 3 rather than Table 1.

ğ‘

layer address

1 byte

tree address

8 bytes

ğ‘¡ğ‘¦ğ‘ğ‘’

1 byte

12 bytes

ğ‘
Figure 18. Compressed address (ADRS  )

Table 3. Member functions for compressed addresses

Member function
ADRS.setLayerAddress(ğ‘™)
ADRS.setTreeAddress(ğ‘¡)
ADRS.setTypeAndClear(ğ‘Œ)
ADRS.setKeyPairAddress(ğ‘–)
ADRS.setChainAddress(ğ‘–)
ADRS.setTreeHeight(ğ‘–)
ADRS.setHashAddress(ğ‘–)
ADRS.setTreeIndex(ğ‘–)
ğ‘– â† ADRS.getKeyPairAddress()
ğ‘– â† ADRS.getTreeIndex()

Expanded notation
ADRS â† toByte(ğ‘™, 1) âˆ¥ ADRS[1 âˆ¶ 22]
ADRS â† ADRS[0 âˆ¶ 1] âˆ¥ toByte(ğ‘¡, 8) âˆ¥ ADRS[9 âˆ¶ 22]
ADRS â† ADRS[0 âˆ¶ 9] âˆ¥ toByte(ğ‘Œ , 1) âˆ¥ toByte(0, 12)
ADRS â† ADRS[0 âˆ¶ 10] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[14 âˆ¶ 22]

ADRS â† ADRS[0 âˆ¶ 14] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[18 âˆ¶ 22]

ADRS â† ADRS[0 âˆ¶ 18] âˆ¥ toByte(ğ‘–, 4)

ğ‘– â† toInt(ADRS[10 âˆ¶ 14], 4)
ğ‘– â† toInt(ADRS[18 âˆ¶ 22], 4)

11.2.1  SLH-DSA  Using  SHA2  for  Security  Category  1

Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-128s
and SLH-DSA-SHA2-128f parameter sets:

Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) =

MGF1-SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)

45

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

PRF(PK.seed, SK.seed, ADRS) =

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ SK.seed))

PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) =

Truncğ‘›(HMAC-SHA-256(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))

F(PK.seed, ADRS, ğ‘€1) =

H(PK.seed, ADRS, ğ‘€2) =

Tâ„“(PK.seed, ADRS, ğ‘€â„“) =

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€1))

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€2))

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€â„“))

11.2.2  SLH-DSA  Using  SHA2  for  Security  Categories  3  and  5

Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-192s,
SLH-DSA-SHA2-192f, SLH-DSA-SHA2-256s, and SLH-DSA-SHA2-256f parameter sets:

Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) =

MGF1-SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)

PRF(PK.seed, SK.seed, ADRS) =

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ SK.seed))

PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) =

Truncğ‘›(HMAC-SHA-512(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))

F(PK.seed, ADRS, ğ‘€1) =

H(PK.seed, ADRS, ğ‘€2) =

Tâ„“(PK.seed, ADRS, ğ‘€â„“) =

Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€1))

Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€2))

Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRSğ‘  âˆ¥ ğ‘€â„“))

46

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

References

[1]  National Institute of Standards and Technology (2023) Digital Signature Standard (DSS).
(Department of Commerce, Washington, D.C.), Federal Information Processing Standards
Publications (FIPS) NIST FIPS 186-5. https://doi.org/10.6028/NIST.FIPS.186-5.

[2]  National Institute of Standards and Technology (2024) Guideline for Using Cryptographic
Standards in the Federal Government: Cryptographic Mechanisms. (National Institute of
Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-175B, Rev.
2. [Forthcoming: will be available at https://csrc.nist.gov/publications].

[3]  National Institute of Standards and Technology (2024) Recommendation for Obtaining
Assurances for Digital Signature Applications. (National Institute of Standards and Technol-
ogy, Gaithersburg, MD), NIST Special Publication (SP) 800-89, Rev. 1. [Forthcoming: will be
available at https://csrc.nist.gov/publications].

[4]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag
SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,
Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2020) SPHINCS+  â€“ Submission to the
NIST post-quantum project, v.3.

[5]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for
Pair-Wise Key-Establishment Using Integer Factorization Cryptography. (National Institute
of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B,
Rev. 2. https://doi.org/10.6028/NIST.SP.800-56Br2.

[6]  National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-Based
Hash and Extendable-Output Functions. (Department of Commerce, Washington, DC),
Federal Information Processing Standards Publication (FIPS) NIST FIPS 202. https://doi.org/
10.6028/NIST.FIPS.202.

[7]  Kelsey JM, Chang SjH, Perlner RA (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-
Hash and ParallelHash. (National Institute of Standards and Technology, Gaithersburg, MD),
NIST Special Publication (SP) 800-185. https://doi.org/10.6028/NIST.SP.800-185.

[8]  National Institute of Standards and Technology (2015) Secure Hash Standard (SHS). (De-
partment of Commerce,  Washington,  D.C.),  Federal Information Processing Standards
Publication (FIPS) NIST FIPS 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.

[9]  National Institute of Standards and Technology (2024) Recommendation for Key Manage-
ment:  Part 1 â€“ General. (National Institute of Standards and Technology, Gaithersburg,
MD), NIST Special Publication (SP) 800-57 Part 1, Rev 6. [Forthcoming: will be available at
https://csrc.nist.gov/publications].

[10]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag
SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,
Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2022) SPHINCS+  â€“ Submission to
the NIST post-quantum project, v.3.1. Available at https://sphincs.org/data/sphincs+-r3.1-
specification.pdf.

47

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

[11]  HÃ¼lsing A, Butin D, Gazdag SL, Rijneveld J, Mohaisen A (2018) XMSS: eXtended Merkle
Signature Scheme. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC)
8391. https://doi.org/10.17487/RFC8391.

[12]  Cooper DA, Apon D, Dang QH, Davidson MS, Dworkin MJ, Miller CA (2020) Recommendation
for Stateful Hash-Based Signature Schemes. (National Institute of Standards and Technology,
Gaithersburg, MD), NIST Special Publication (SP) 800-208. https://doi.org/10.6028/NIST.SP.
800-208.

[13]  Merkle RC (1979) Secrecy, Authentication, and Public Key Systems. Ph.D. thesis. Stanford

university, .

[14]  Barker EB, Kelsey JM (2015) Recommendation for Random Number Generation Using
Deterministic Random Bit Generators. (National Institute of Standards and Technology,
Gaithersburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/
NIST.SP.800-90Ar1.

[15]  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-
mendation for the Entropy Sources Used for Random Bit Generation. (National Institute
of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.
https://doi.org/10.6028/NIST.SP.800-90B.

[16]  Barker EB, Kelsey JM, McKay KA, Roginsky AL, SÃ¶nmez Turan M (2022) Recommendation for
Random Bit Generator (RBG) Constructions. (National Institute of Standards and Technology,
Gaithersburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/
NIST.SP.800-90C.4pd.

[17]  Kannwischer MJ, GenÃªt A, Butin D, KrÃ¤mer J, Buchmann J (2018) Differential Power Analysis
of XMSS and SPHINCS. Constructive Side-Channel Analysis and Secure Design, eds Fan J,
Gierlichs B (Springer International Publishing, Cham), pp 168â€“188. https://doi.org/10.1007/
978-3-319-89641-0_10.

[18]  Castelnovi L, Martinelli A, Prest T (2018) Grafting Trees: A Fault Attack Against the SPHINCS
Framework. Post-Quantum Cryptography, eds Lange T, Steinwandt R (Springer International
Publishing, Cham), pp 165â€“184. https://doi.org/10.1007/978-3-319-79063-3_8.

[19]  GenÃªt A, Kannwischer MJ, Pelletier H, McLauchlan A (2018) Practical Fault Injection Attacks

on SPHINCS, Cryptology ePrint Archive preprint. https://ia.cr/2018/674.

[20]  Amiet D, Leuenberger L, Curiger A, Zbinden P (2020) FPGA-based SPHINCS+ Implementa-
tions: Mind the Glitch. 2020 23rd Euromicro Conference on Digital System Design (DSD), pp
229â€“237. https://doi.org/10.1109/DSD51259.2020.00046.

[21]  GenÃªt A (2023) On Protecting SPHINCS+ Against Fault Attacks. IACR Transactions on Cryp-
tographic Hardware and Embedded Systems 2023(2):80â€“114. https://doi.org/10.46586/
tches.v2023.i2.80-114.

[22]  Groot Bruinderink L, HÃ¼lsing A (2018) â€œOops, I Did It Againâ€ â€“ Security of One-Time Signatures
Under Two-Message Attacks. Selected Areas in Cryptography â€“ SAC 2017, eds Adams C,
Camenisch J (Springer International Publishing, Cham), pp 299â€“322. https://doi.org/10.
1007/978-3-319-72565-9_15.

48

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

[23]  Housley R (2009) Cryptographic Message Syntax (CMS). (Internet Engineering Task Force
(IETF)), IETF Request for Comments (RFC) 5652. https://doi.org/10.17487/RFC5652.

[24]  National Institute of Standards and Technology (2024) Recommendation for Additional
Stateless Hash-Based Digital Signature Parameter Sets. (National Institute of Standards and
Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-230. [Forthcoming: will
be available at https://csrc.nist.gov/publications].

[25]  National Institute of Standards and Technology (2016) Submission Requirements and Eval-
uation Criteria for the Post-Quantum Cryptography Standardization Process. Available
at https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/
call-for-proposals-final-dec-2016.pdf.

[26]  Alagic G, Apon D, Cooper DA, Dang QH, Dang T, Kelsey JM, Lichtinger J, Liu YK, Miller CA,
Moody D, Peralta R, Perlner RA, Robinson A, Smith-Tone D (2022) Status Report on the
Third Round of the NIST Post-Quantum Cryptography Standardization Process. (National
Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal
Report (IR) NIST IR 8413-upd1, includes updates as of September 26, 2022. https://doi.org/
10.6028/NIST.IR.8413-upd1.

[27]  HÃ¼lsing A, Kudinov M (2022) Recovering the Tight Security Proof of SPHINCS+ . Advances in
Cryptology â€“ ASIACRYPT 2022, eds Agrawal S, Lin D (Springer Nature Switzerland, Cham),
pp 3â€“33. https://doi.org/10.1007/978-3-031-22972-5_1.

[28]  Stern J, Pointcheval D, Malone-Lee J, Smart NP (2002) Flaws in Applying Proof Methodologies
to Signature Schemes. Advances in Cryptology â€” CRYPTO 2002, ed Yung M (Springer Berlin
Heidelberg, Berlin, Heidelberg), pp 93â€“110. https://doi.org/10.1007/3-540-45708-9_7.

[29]  Cremers C, DÃ¼zlÃ¼ S, Fiedler R, Janson C, Fischlin M (2021) BUFFing Signature Schemes
Beyond Unforgeability and the Case of Post-Quantum Signatures. 2021 IEEE Symposium on
Security and Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696â€“1714.
https://doi.org/10.1109/SP40001.2021.00093.

[30]  Moriarty K, Kaliski B, Jonsson J, Rusch A (2016) PKCS #1: RSA Cryptography Specifications
Version 2.2. (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 8017.
https://doi.org/10.17487/RFC8017.

[31]  National Institute of Standards and Technology (2008) The Keyed-Hash Message Authentica-
tion Code (HMAC). (Department of Commerce, Washington, DC), Federal Information Pro-
cessing Standards Publication (FIPS) NIST FIPS 198-1. https://doi.org/10.6028/NIST.FIPS.198-
1.

[32]  Krawczyk H, Bellare M, Canetti R (1997) HMAC: Keyed-Hashing for Message Authentication.
(Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 2104. https:
//doi.org/10.17487/RFC2104.

[33]  Stern M (2021) Re: Diversity of signature schemes. Available at https://groups.google.com/

a/list.nist.gov/g/pqc-forum/c/2LEoSpskELs/m/LkUdQ5mKAwAJ.

[34]  Antonov S (2022) ROUND 3 OFFICIAL COMMENT: SPHINCS+. Available at https://groups.

google.com/a/list.nist.gov/g/pqc-forum/c/FVItvyRea28/m/mGaRi5iZBwAJ.

49

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

[35]  Perlner R, Kelsey J, Cooper D (2022) Breaking Category Five SPHINCS+Â withÂ SHA-256. Post-
Quantum Cryptography, eds Cheon JH, Johansson T (Springer International Publishing,
Cham), pp 501â€“522. https://doi.org/10.1007/978-3-031-17234-2_23.

50

FIPS 205

STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD

Appendix  A  â€”  Differences  From  the  SPHINCS+  Submission

This standard is based on Version 3.1 of the SPHINCS+  specification [10] and contains several
minor modifications compared to Version 3 [4], which was submitted at the beginning of round
three of the NIST PQC Standardization process:

â€¢  Two new address types â€” WOTS_PRF and FORS_PRF â€” were defined for WOTS+ and FORS

secret key value generation.

â€¢  PK.seed was added as an input to PRF in order to mitigate multi-key attacks.

â€¢  For the category 3 and 5 SHA2 parameter sets, SHA-256 was replaced by SHA-512 in Hğ‘šğ‘ ğ‘”,
PRFğ‘šğ‘ ğ‘”, H, and Tâ„“  based on weaknesses that were discovered when using SHA-256 to
obtain category 5 security [33, 34, 35].

â€¢  ğ‘… and PK.seed were added as inputs to MGF1 when computing Hğ‘šğ‘ ğ‘”  for the SHA2
parameter sets in order to mitigate multi-target long-message second preimage attacks.

This standard also differs from the Version 3 specification in its method for extracting bits from
the message digest to select a FORS key.  This change was made in order to align with the
reference implementation that was submitted along with the round three specification.  The
description of the method for extracting indices for FORS signature generation and verification
from the message digest was also changed due to ambiguity in the submitted specification. The
method described in this standard is not compatible with the method used in the reference
implementation that was submitted along with the round three specification. Additionally, line 6
in both wots_sign and wots_pkFromSig were changed to match the reference implementation,
as the pseudocode in [10, 4] will sometimes shift ğ‘ğ‘ ğ‘¢ğ‘š by the incorrect amount when ğ‘™ğ‘”ğ‘¤ is not
4.

This standard approves the use of only 12 of the 36 parameter sets defined in [10, 4]. As specified
in Section 11, only the â€˜simpleâ€™ instances of the SHA2 and SHAKE parameter sets are approved.

A.1  Changes  From  FIPS  205  Initial  Public  Draft
The differences from Version 3 of the SPHINCS+  specification described in Appendix A were
included in the draft version of this standard (FIPS 205 ipd) that was posted on August 24, 2023.
Based on comments that were submitted on FIPS 205 ipd, the SLH-DSA signature generation and
verification functions were modified to include domain separation cases in which the message
is signed directly and in which a digest of the message is signed.  The changes were made by
modifying the inputs to the signing and verification functions (see Algorithms 22, 23, 24, and
25).

51

